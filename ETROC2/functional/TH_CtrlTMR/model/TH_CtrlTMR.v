/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ../output/TH_CtrlTMR.v                                                                 *
 *                                                                                                  *
 * user    : qsun                                                                                   *
 * host    : hepasic2.physics.smu.edu                                                               *
 * date    : 01/07/2021 17:52:02                                                                    *
 *                                                                                                  *
 * workdir : /users/qsun/workarea/tsmc65nm/ETROC_PLL/digital_work/ETROC2_TH_Ctrl/tmr/work           *
 * cmd     : /users/qsun/workarea/tsmc65nm/ETROC_PLL/digital_work/tmrg/bin/tmrg --log tmrg.log      *
 *           --include --inc-dir ../../ETROC_TH_Ctrl-main/ --lib ../simplified_std_cell_lib.v --lib *
 *           ../../ETROC_TH_Ctrl-main/powerOnResetLong.v --lib ../../libs/customDigitalLib.v -c     *
 *           ../config/tmrg.cnf                                                                     *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: ../../ETROC_TH_Ctrl-main/TH_Ctrl.v                                                     *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2021-07-01 17:50:55.914238                                         *
 *           File Size         : 21314                                                              *
 *           MD5 hash          : 30dc691c0a1f651e27072fca7e8f15ed                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ns/10ps

`define  AccumulatorBit 16 

module TH_CtrlTMR(
     CLK,
     RSTn,
     DiscriPul,
     Bypass,
     CLKEn,
     ScanStart,
     ScanDone,
     DAC,
     TH_offset,
     TH,
     BL,
     NW,
     Acc,
     StateOut,
     VDD,
     VSS
);
parameter    T1mS=16'd4_999;      // it is 16'd39_999 in the original design
parameter    T50uS=16'd1999;
parameter    T50p05uS=16'd2001;
localparam    INIT=3'd0;
localparam    SAR_INIT=3'd1;
localparam    SAR_SCAN=3'd2;
localparam    SAR_DONE=3'd3;
localparam    LINEAR_INIT=3'd4;
localparam    LINEAR_SCAN=3'd5;
localparam    IDLE=3'd6;
wire ScanDoneC;
wire ScanDoneB;
wire ScanDoneA;
wire CLKC;
wire CLKB;
wire CLKA;
wire DiscriPulC;
wire DiscriPulB;
wire DiscriPulA;
wire CLKEnC;
wire CLKEnB;
wire CLKEnA;
wire BypassC;
wire BypassB;
wire BypassA;
wire ScanStartC;
wire ScanStartB;
wire ScanStartA;
wire RSTnC;
wire RSTnB;
wire RSTnA;
wire tmrErrorC;
wor stateTmrErrorC;
wor ministateTmrErrorC;
wor iTmrErrorC;
wor bl_scan_InsttmrErrorC;
wor TH_regTmrErrorC;
wor ScanActiveTmrErrorC;
wor SAR_Scan_DoneTmrErrorC;
wor SAR_Scan_BusyTmrErrorC;
wor PulGen_Done_InsttmrErrorC;
wor NW_regTmrErrorC;
wor Linear_Scan_BusyTmrErrorC;
wor CMD_regTmrErrorC;
wor BL_regTmrErrorC;
wor BL_intTmrErrorC;
wor Auto_Scan_DoneTmrErrorC;
wire ministateVotedC;
wire [2:0] stateVotedC;
wire CMD_regVotedC;
wire [9:0] BL_intVotedC;
wire Linear_Scan_BusyVotedC;
wire [4:0] iVotedC;
wire [9:0] TH_regVotedC;
wire [3:0] NW_regVotedC;
wire [9:0] BL_regVotedC;
wire SAR_Scan_DoneVotedC;
wire SAR_Scan_BusyVotedC;
wire Auto_Scan_DoneVotedC;
wire ScanActiveVotedC;
wire tmrErrorB;
wor stateTmrErrorB;
wor ministateTmrErrorB;
wor iTmrErrorB;
wor bl_scan_InsttmrErrorB;
wor TH_regTmrErrorB;
wor ScanActiveTmrErrorB;
wor SAR_Scan_DoneTmrErrorB;
wor SAR_Scan_BusyTmrErrorB;
wor PulGen_Done_InsttmrErrorB;
wor NW_regTmrErrorB;
wor Linear_Scan_BusyTmrErrorB;
wor CMD_regTmrErrorB;
wor BL_regTmrErrorB;
wor BL_intTmrErrorB;
wor Auto_Scan_DoneTmrErrorB;
wire ministateVotedB;
wire SAR_Scan_DoneVotedB;
wire [2:0] stateVotedB;
wire CMD_regVotedB;
wire Linear_Scan_BusyVotedB;
wire [9:0] BL_intVotedB;
wire [9:0] TH_regVotedB;
wire [4:0] iVotedB;
wire [3:0] NW_regVotedB;
wire [9:0] BL_regVotedB;
wire Auto_Scan_DoneVotedB;
wire SAR_Scan_BusyVotedB;
wire ScanActiveVotedB;
wire tmrErrorA;
wor stateTmrErrorA;
wor ministateTmrErrorA;
wor iTmrErrorA;
wor bl_scan_InsttmrErrorA;
wor TH_regTmrErrorA;
wor ScanActiveTmrErrorA;
wor SAR_Scan_DoneTmrErrorA;
wor SAR_Scan_BusyTmrErrorA;
wor PulGen_Done_InsttmrErrorA;
wor NW_regTmrErrorA;
wor Linear_Scan_BusyTmrErrorA;
wor CMD_regTmrErrorA;
wor BL_regTmrErrorA;
wor BL_intTmrErrorA;
wor Auto_Scan_DoneTmrErrorA;
wire [2:0] stateVotedA;
wire ministateVotedA;
wire [9:0] BL_intVotedA;
wire Linear_Scan_BusyVotedA;
wire CMD_regVotedA;
wire SAR_Scan_DoneVotedA;
wire [4:0] iVotedA;
wire [9:0] TH_regVotedA;
wire [9:0] BL_regVotedA;
wire [3:0] NW_regVotedA;
wire Auto_Scan_DoneVotedA;
wire SAR_Scan_BusyVotedA;
wire ScanActiveVotedA;
wire tmrError;
wor stateVotedTmrError;
wor ministateVotedTmrError;
wor TH_regVotedTmrError;
wor SS_Scan_DoneTmrError;
wor NW_regVotedTmrError;
wor BL_regVotedTmrError;
wor BLAccTmrError;
wor Auto_Scan_DoneVotedTmrError;
wire [9:0] TH_regVoted;
wire [3:0] NW_regVoted;
wire [2:0] stateVoted;
wire Auto_Scan_DoneVoted;
wire [`AccumulatorBit-1:0] BLAcc;
wire SS_Scan_Done;
wire ministateVoted;
wire [9:0] BL_regVoted;
input CLK;
input RSTn;
input DiscriPul;
input Bypass;
input CLKEn;
input ScanStart;
output wire    ScanDone;
input [9:0] DAC;
input [5:0] TH_offset;
output wire   [9:0] TH;
output wire   [9:0] BL;
output wire   [3:0] NW;
output wire   [`AccumulatorBit-1:0] Acc;
output wire   [2:0] StateOut;
inout VDD, VSS;
reg  ScanActiveA;
reg  ScanActiveB;
reg  ScanActiveC;
wire L2H_ScanStartA;
wire L2H_ScanStartB;
wire L2H_ScanStartC;
wire L2H_ScanDoneA;
wire L2H_ScanDoneB;
wire L2H_ScanDoneC;
wire resetnA;
wire resetnB;
wire resetnC;
wire clkEnableAutoA =  (ScanActiveA||L2H_ScanStartA||L2H_ScanDoneA||tmrErrorA||!resetnA);
wire clkEnableAutoB =  (ScanActiveB||L2H_ScanStartB||L2H_ScanDoneB||tmrErrorB||!resetnB);
wire clkEnableAutoC =  (ScanActiveC||L2H_ScanStartC||L2H_ScanDoneC||tmrErrorC||!resetnC);
wire clkEnableGlithesA =  (BypassA) ? CLKEnA : clkEnableAutoA;
wire clkEnableGlithesB =  (BypassB) ? CLKEnB : clkEnableAutoB;
wire clkEnableGlithesC =  (BypassC) ? CLKEnC : clkEnableAutoC;
wire clkEnableA;
wire clkEnableB;
wire clkEnableC;
wire clkGatedA;
wire clkGatedB;
wire clkGatedC;

glitchFilter clkEnGFA (
          .in(clkEnableGlithesA),
          .out(clkEnableA)
          );

glitchFilter clkEnGFB (
          .in(clkEnableGlithesB),
          .out(clkEnableB)
          );

glitchFilter clkEnGFC (
          .in(clkEnableGlithesC),
          .out(clkEnableC)
          );

CKLNQD6 CG_sourceA (
          .CP(CLKA),
          .Q(clkGatedA),
          .TE(1'b0),
          .E(clkEnableA)
          );

CKLNQD6 CG_sourceB (
          .CP(CLKB),
          .Q(clkGatedB),
          .TE(1'b0),
          .E(clkEnableB)
          );

CKLNQD6 CG_sourceC (
          .CP(CLKC),
          .Q(clkGatedC),
          .TE(1'b0),
          .E(clkEnableC)
          );
wire porA;
wire porB;
wire porC;

powerOnResetLong PORA (
          .POR(porA)
          );

powerOnResetLong PORB (
          .POR(porB)
          );

powerOnResetLong PORC (
          .POR(porC)
          );
assign resetnA =  (! porA )&RSTnA;
assign resetnB =  (! porB )&RSTnB;
assign resetnC =  (! porC )&RSTnC;

PulGen_StartTMR PulGen_Start_Inst (
          .ScanStartA(ScanStartA),
          .ScanStartB(ScanStartB),
          .ScanStartC(ScanStartC),
          .L2H_ScanStartA(L2H_ScanStartA),
          .L2H_ScanStartB(L2H_ScanStartB),
          .L2H_ScanStartC(L2H_ScanStartC)
          );

PulGen_DoneTMR PulGen_Done_Inst (
          .CLKA(clkGatedA),
          .CLKB(clkGatedB),
          .CLKC(clkGatedC),
          .resetnA(resetnA),
          .resetnB(resetnB),
          .resetnC(resetnC),
          .ScanDoneA(ScanDoneA),
          .ScanDoneB(ScanDoneB),
          .ScanDoneC(ScanDoneC),
          .L2H_ScanDoneA(L2H_ScanDoneA),
          .L2H_ScanDoneB(L2H_ScanDoneB),
          .L2H_ScanDoneC(L2H_ScanDoneC),
          .tmrErrorA(PulGen_Done_InsttmrErrorA),
          .tmrErrorB(PulGen_Done_InsttmrErrorB),
          .tmrErrorC(PulGen_Done_InsttmrErrorC)
          );
reg  CMD_regA;
reg  CMD_regB;
reg  CMD_regC;
wire CMDA;
wire CMDB;
wire CMDC;
assign CMDA =  (BypassA) ? L2H_ScanStartA : CMD_regVotedA;
assign CMDB =  (BypassB) ? L2H_ScanStartB : CMD_regVotedB;
assign CMDC =  (BypassC) ? L2H_ScanStartC : CMD_regVotedC;
wire [`AccumulatorBit-1:0] BLAccA;
wire [`AccumulatorBit-1:0] BLAccB;
wire [`AccumulatorBit-1:0] BLAccC;
wire BLScan_BusyA;
wire BLScan_BusyB;
wire BLScan_BusyC;
wire NoiseFlagA;
wire NoiseFlagB;
wire NoiseFlagC;
wire clkGated_blA;
wire clkGated_blB;
wire clkGated_blC;

CKLNQD6 CG_blA (
          .CP(clkGatedA),
          .Q(clkGated_blA),
          .TE(1'b0),
          .E(clkEnableA)
          );

CKLNQD6 CG_blB (
          .CP(clkGatedB),
          .Q(clkGated_blB),
          .TE(1'b0),
          .E(clkEnableB)
          );

CKLNQD6 CG_blC (
          .CP(clkGatedC),
          .Q(clkGated_blC),
          .TE(1'b0),
          .E(clkEnableC)
          );

bl_scanTMR bl_scan_Inst (
          .CLKA(clkGated_blA),
          .CLKB(clkGated_blB),
          .CLKC(clkGated_blC),
          .RSTnA(resetnA),
          .RSTnB(resetnB),
          .RSTnC(resetnC),
          .porA(porA),
          .porB(porB),
          .porC(porC),
          .DiscriPulA(DiscriPulA),
          .DiscriPulB(DiscriPulB),
          .DiscriPulC(DiscriPulC),
          .CMDA(CMDA),
          .CMDB(CMDB),
          .CMDC(CMDC),
          .AccA(BLAccA),
          .AccB(BLAccB),
          .AccC(BLAccC),
          .ScanBusyA(BLScan_BusyA),
          .ScanBusyB(BLScan_BusyB),
          .ScanBusyC(BLScan_BusyC),
          .NoiseFlagA(NoiseFlagA),
          .NoiseFlagB(NoiseFlagB),
          .NoiseFlagC(NoiseFlagC),
          .tmrErrorA(bl_scan_InsttmrErrorA),
          .tmrErrorB(bl_scan_InsttmrErrorB),
          .tmrErrorC(bl_scan_InsttmrErrorC)
          );
reg  BLScan_Busy_int1A;
reg  BLScan_Busy_int2A;
reg  BLScan_Busy_int1B;
reg  BLScan_Busy_int2B;
reg  BLScan_Busy_int1C;
reg  BLScan_Busy_int2C;
wire H2L_BLScan_BusyA;
wire H2L_BLScan_BusyB;
wire H2L_BLScan_BusyC;

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               begin
                    BLScan_Busy_int1A <= 1'b0;
                    BLScan_Busy_int2A <= 1'b0;
               end
          else
               begin
                    BLScan_Busy_int1A <= BLScan_BusyA;
                    BLScan_Busy_int2A <= BLScan_Busy_int1A;
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               begin
                    BLScan_Busy_int1B <= 1'b0;
                    BLScan_Busy_int2B <= 1'b0;
               end
          else
               begin
                    BLScan_Busy_int1B <= BLScan_BusyB;
                    BLScan_Busy_int2B <= BLScan_Busy_int1B;
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               begin
                    BLScan_Busy_int1C <= 1'b0;
                    BLScan_Busy_int2C <= 1'b0;
               end
          else
               begin
                    BLScan_Busy_int1C <= BLScan_BusyC;
                    BLScan_Busy_int2C <= BLScan_Busy_int1C;
               end
     end
assign H2L_BLScan_BusyA =  BLScan_Busy_int2A&(! BLScan_BusyA );
assign H2L_BLScan_BusyB =  BLScan_Busy_int2B&(! BLScan_BusyB );
assign H2L_BLScan_BusyC =  BLScan_Busy_int2C&(! BLScan_BusyC );
reg  SS_Scan_DoneA;
reg  SS_Scan_DoneB;
reg  SS_Scan_DoneC;

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               SS_Scan_DoneA <= 1'b0;
          else
               begin
                    if (L2H_ScanStartA||!BypassA)
                         SS_Scan_DoneA <= 1'b0;
                    else
                         if (H2L_BLScan_BusyA)
                              SS_Scan_DoneA <= 1'b1;
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               SS_Scan_DoneB <= 1'b0;
          else
               begin
                    if (L2H_ScanStartB||!BypassB)
                         SS_Scan_DoneB <= 1'b0;
                    else
                         if (H2L_BLScan_BusyB)
                              SS_Scan_DoneB <= 1'b1;
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               SS_Scan_DoneC <= 1'b0;
          else
               begin
                    if (L2H_ScanStartC||!BypassC)
                         SS_Scan_DoneC <= 1'b0;
                    else
                         if (H2L_BLScan_BusyC)
                              SS_Scan_DoneC <= 1'b1;
               end
     end
reg  SAR_Scan_DoneA;
reg  SAR_Scan_DoneB;
reg  SAR_Scan_DoneC;
reg  Auto_Scan_DoneA;
reg  Auto_Scan_DoneB;
reg  Auto_Scan_DoneC;
reg  [15:0] counter_clkA;
reg  [15:0] counter_clkB;
reg  [15:0] counter_clkC;

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               counter_clkA <= 0;
          else
               begin
                    if (BypassA||L2H_ScanStartA||SAR_Scan_DoneVotedA||Auto_Scan_DoneVotedA||counter_clkA==T1mS)
                         counter_clkA <= 0;
                    else
                         counter_clkA <= counter_clkA+1;
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               counter_clkB <= 0;
          else
               begin
                    if (BypassB||L2H_ScanStartB||SAR_Scan_DoneVotedB||Auto_Scan_DoneVotedB||counter_clkB==T1mS)
                         counter_clkB <= 0;
                    else
                         counter_clkB <= counter_clkB+1;
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               counter_clkC <= 0;
          else
               begin
                    if (BypassC||L2H_ScanStartC||SAR_Scan_DoneVotedC||Auto_Scan_DoneVotedC||counter_clkC==T1mS)
                         counter_clkC <= 0;
                    else
                         counter_clkC <= counter_clkC+1;
               end
     end
reg  [4:0] iA;
reg  [4:0] iB;
reg  [4:0] iC;
reg  [9:0] TH_regA;
reg  [9:0] TH_regB;
reg  [9:0] TH_regC;
reg  [9:0] BL_intA;
reg  [9:0] BL_intB;
reg  [9:0] BL_intC;
reg  SAR_Scan_BusyA;
reg  SAR_Scan_BusyB;
reg  SAR_Scan_BusyC;
reg  Linear_Scan_BusyA;
reg  Linear_Scan_BusyB;
reg  Linear_Scan_BusyC;
reg  [2:0] stateA;
reg  [2:0] stateB;
reg  [2:0] stateC;
reg  [4:0] i_nextA;
reg  [4:0] i_nextB;
reg  [4:0] i_nextC;
reg  [9:0] TH_reg_nextA;
reg  [9:0] TH_reg_nextB;
reg  [9:0] TH_reg_nextC;
reg  [9:0] BL_int_nextA;
reg  [9:0] BL_int_nextB;
reg  [9:0] BL_int_nextC;
reg  SAR_Scan_Busy_nextA;
reg  SAR_Scan_Busy_nextB;
reg  SAR_Scan_Busy_nextC;
reg  SAR_Scan_Done_nextA;
reg  SAR_Scan_Done_nextB;
reg  SAR_Scan_Done_nextC;
reg  Linear_Scan_Busy_nextA;
reg  Linear_Scan_Busy_nextB;
reg  Linear_Scan_Busy_nextC;
reg  CMD_reg_nextA;
reg  CMD_reg_nextB;
reg  CMD_reg_nextC;
reg  [2:0] state_nextA;
reg  [2:0] state_nextB;
reg  [2:0] state_nextC;
initial
     begin
          stateA <= LINEAR_INIT;
     end
initial
     begin
          stateB <= LINEAR_INIT;
     end
initial
     begin
          stateC <= LINEAR_INIT;
     end

always @( posedge clkGatedA )
     begin
          if (!resetnA||BypassA)
               begin
                    iA <= 5'd0;
                    TH_regA <= 10'd0;
                    BL_intA <= 10'd0;
                    SAR_Scan_BusyA <= 1'b0;
                    SAR_Scan_DoneA <= 1'b0;
                    Linear_Scan_BusyA <= 1'b0;
                    CMD_regA <= 1'b0;
                    stateA <= INIT;
               end
          else
               begin
                    iA <= i_nextA;
                    TH_regA <= TH_reg_nextA;
                    BL_intA <= BL_int_nextA;
                    SAR_Scan_BusyA <= SAR_Scan_Busy_nextA;
                    SAR_Scan_DoneA <= SAR_Scan_Done_nextA;
                    Linear_Scan_BusyA <= Linear_Scan_Busy_nextA;
                    CMD_regA <= CMD_reg_nextA;
                    stateA <= state_nextA;
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB||BypassB)
               begin
                    iB <= 5'd0;
                    TH_regB <= 10'd0;
                    BL_intB <= 10'd0;
                    SAR_Scan_BusyB <= 1'b0;
                    SAR_Scan_DoneB <= 1'b0;
                    Linear_Scan_BusyB <= 1'b0;
                    CMD_regB <= 1'b0;
                    stateB <= INIT;
               end
          else
               begin
                    iB <= i_nextB;
                    TH_regB <= TH_reg_nextB;
                    BL_intB <= BL_int_nextB;
                    SAR_Scan_BusyB <= SAR_Scan_Busy_nextB;
                    SAR_Scan_DoneB <= SAR_Scan_Done_nextB;
                    Linear_Scan_BusyB <= Linear_Scan_Busy_nextB;
                    CMD_regB <= CMD_reg_nextB;
                    stateB <= state_nextB;
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC||BypassC)
               begin
                    iC <= 5'd0;
                    TH_regC <= 10'd0;
                    BL_intC <= 10'd0;
                    SAR_Scan_BusyC <= 1'b0;
                    SAR_Scan_DoneC <= 1'b0;
                    Linear_Scan_BusyC <= 1'b0;
                    CMD_regC <= 1'b0;
                    stateC <= INIT;
               end
          else
               begin
                    iC <= i_nextC;
                    TH_regC <= TH_reg_nextC;
                    BL_intC <= BL_int_nextC;
                    SAR_Scan_BusyC <= SAR_Scan_Busy_nextC;
                    SAR_Scan_DoneC <= SAR_Scan_Done_nextC;
                    Linear_Scan_BusyC <= Linear_Scan_Busy_nextC;
                    CMD_regC <= CMD_reg_nextC;
                    stateC <= state_nextC;
               end
     end

always @( * )
     begin
          case (stateVotedA)
               INIT : 
                    begin
                         if (L2H_ScanStartA)
                              state_nextA =  SAR_INIT;
                         else
                              state_nextA =  INIT;
                    end
               SAR_INIT : 
                    begin
                         state_nextA =  SAR_SCAN;
                    end
               SAR_SCAN : 
                    begin
                         if (iVotedA==5'd10&&counter_clkA==T1mS)
                              state_nextA =  SAR_DONE;
                         else
                              state_nextA =  SAR_SCAN;
                    end
               SAR_DONE : 
                    begin
                         state_nextA =  LINEAR_INIT;
                    end
               LINEAR_INIT : 
                    begin
                         state_nextA =  LINEAR_SCAN;
                    end
               LINEAR_SCAN : 
                    begin
                         if (iVotedA==5'd25&&counter_clkA==T1mS)
                              state_nextA =  IDLE;
                         else
                              state_nextA =  LINEAR_SCAN;
                    end
               IDLE : 
                    begin
                         if (L2H_ScanStartA)
                              state_nextA =  SAR_INIT;
                         else
                              state_nextA =  IDLE;
                    end
               default : 
                    begin
                         state_nextA =  INIT;
                    end
          endcase
     end

always @( * )
     begin
          case (stateVotedB)
               INIT : 
                    begin
                         if (L2H_ScanStartB)
                              state_nextB =  SAR_INIT;
                         else
                              state_nextB =  INIT;
                    end
               SAR_INIT : 
                    begin
                         state_nextB =  SAR_SCAN;
                    end
               SAR_SCAN : 
                    begin
                         if (iVotedB==5'd10&&counter_clkB==T1mS)
                              state_nextB =  SAR_DONE;
                         else
                              state_nextB =  SAR_SCAN;
                    end
               SAR_DONE : 
                    begin
                         state_nextB =  LINEAR_INIT;
                    end
               LINEAR_INIT : 
                    begin
                         state_nextB =  LINEAR_SCAN;
                    end
               LINEAR_SCAN : 
                    begin
                         if (iVotedB==5'd25&&counter_clkB==T1mS)
                              state_nextB =  IDLE;
                         else
                              state_nextB =  LINEAR_SCAN;
                    end
               IDLE : 
                    begin
                         if (L2H_ScanStartB)
                              state_nextB =  SAR_INIT;
                         else
                              state_nextB =  IDLE;
                    end
               default : 
                    begin
                         state_nextB =  INIT;
                    end
          endcase
     end

always @( * )
     begin
          case (stateVotedC)
               INIT : 
                    begin
                         if (L2H_ScanStartC)
                              state_nextC =  SAR_INIT;
                         else
                              state_nextC =  INIT;
                    end
               SAR_INIT : 
                    begin
                         state_nextC =  SAR_SCAN;
                    end
               SAR_SCAN : 
                    begin
                         if (iVotedC==5'd10&&counter_clkC==T1mS)
                              state_nextC =  SAR_DONE;
                         else
                              state_nextC =  SAR_SCAN;
                    end
               SAR_DONE : 
                    begin
                         state_nextC =  LINEAR_INIT;
                    end
               LINEAR_INIT : 
                    begin
                         state_nextC =  LINEAR_SCAN;
                    end
               LINEAR_SCAN : 
                    begin
                         if (iVotedC==5'd25&&counter_clkC==T1mS)
                              state_nextC =  IDLE;
                         else
                              state_nextC =  LINEAR_SCAN;
                    end
               IDLE : 
                    begin
                         if (L2H_ScanStartC)
                              state_nextC =  SAR_INIT;
                         else
                              state_nextC =  IDLE;
                    end
               default : 
                    begin
                         state_nextC =  INIT;
                    end
          endcase
     end

always @( posedge clkGatedA )
     begin
          if (!resetnA||BypassA)
               begin
                    i_nextA <= 5'd0;
                    TH_reg_nextA <= 10'd0;
                    BL_int_nextA <= 10'd0;
                    SAR_Scan_Busy_nextA <= 1'b0;
                    SAR_Scan_Done_nextA <= 1'b0;
                    Linear_Scan_Busy_nextA <= 1'b0;
                    CMD_reg_nextA <= 1'b0;
               end
          else
               begin
                    case (state_nextA)
                         INIT : 
                              begin
                                   i_nextA <= 5'd0;
                                   TH_reg_nextA <= 10'd0;
                                   BL_int_nextA <= 10'd0;
                                   SAR_Scan_Busy_nextA <= 1'b0;
                                   SAR_Scan_Done_nextA <= 1'b0;
                                   Linear_Scan_Busy_nextA <= 1'b0;
                                   CMD_reg_nextA <= 1'b0;
                              end
                         SAR_INIT : 
                              begin
                                   i_nextA <= 5'd1;
                                   TH_reg_nextA <= 10'b10_0000_0000;
                                   BL_int_nextA <= 10'd0;
                                   SAR_Scan_Busy_nextA <= 1'b0;
                                   SAR_Scan_Done_nextA <= 1'b0;
                                   Linear_Scan_Busy_nextA <= 1'b0;
                                   CMD_reg_nextA <= 1'b0;
                              end
                         SAR_SCAN : 
                              begin
                                   if (iVotedA<5'd9&&counter_clkA==T1mS)
                                        begin
                                             i_nextA <= iVotedA+1'b1;
                                             if (BLAccA>2048)             // it was 16384
                                                  TH_reg_nextA[10-iVotedA]  <= 1'b1;
                                             else
                                                  TH_reg_nextA[10-iVotedA]  <= 1'b0;
                                             TH_reg_nextA[9-iVotedA]  <= 1'b1;
                                        end
                                   else
                                        if (iVotedA==5'd9&&counter_clkA==T1mS)
                                             begin
                                                  i_nextA <= iVotedA+1'b1;
                                                  if (BLAccA>2048)
                                                       TH_reg_nextA[0]  <= 1'b1;
                                                  else
                                                       TH_reg_nextA[0]  <= 1'b0;
                                             end
                                   BL_int_nextA <= 10'd0;
                                   SAR_Scan_Busy_nextA <= 1'b1;
                                   SAR_Scan_Done_nextA <= 1'b0;
                                   Linear_Scan_Busy_nextA <= 1'b0;
                                   if (counter_clkA==T50uS)
                                        CMD_reg_nextA <= 1'b1;
                                   else
                                        if (counter_clkA==T50p05uS)
                                             CMD_reg_nextA <= 1'b0;
                              end
                         SAR_DONE : 
                              begin
                                   i_nextA <= 5'd0;
                                   TH_reg_nextA <= TH_regVotedA;
                                   BL_int_nextA <= TH_regVotedA;
                                   SAR_Scan_Busy_nextA <= 1'b0;
                                   SAR_Scan_Done_nextA <= 1'b1;
                                   Linear_Scan_Busy_nextA <= 1'b0;
                                   CMD_reg_nextA <= 1'b0;
                              end
                         LINEAR_INIT : 
                              begin
                                   i_nextA <= 5'd1;
                                   TH_reg_nextA <= TH_regVotedA-10'd12;
                                   BL_int_nextA <= TH_regVotedA;
                                   SAR_Scan_Busy_nextA <= 1'b0;
                                   SAR_Scan_Done_nextA <= 1'b1;
                                   Linear_Scan_Busy_nextA <= 1'b0;
                                   CMD_reg_nextA <= 1'b0;
                              end
                         LINEAR_SCAN : 
                              begin
                                   if (iVotedA<5'd25&&counter_clkA==T1mS)
                                        begin
                                             i_nextA <= iVotedA+1'b1;
                                             TH_reg_nextA <= TH_regVotedA+1'b1;
                                        end
                                   BL_int_nextA <= BL_intVotedA;
                                   SAR_Scan_Busy_nextA <= 1'b0;
                                   SAR_Scan_Done_nextA <= 1'b0;
                                   Linear_Scan_Busy_nextA <= 1'b1;
                                   if (counter_clkA==T50uS)
                                        CMD_reg_nextA <= 1'b1;
                                   else
                                        if (counter_clkA==T50p05uS)
                                             CMD_reg_nextA <= 1'b0;
                              end
                         IDLE : 
                              begin
                                   i_nextA <= 5'd0;
                                   TH_reg_nextA <= TH_regVotedA;
                                   BL_int_nextA <= BL_intVotedA;
                                   SAR_Scan_Busy_nextA <= 1'b0;
                                   SAR_Scan_Done_nextA <= 1'b0;
                                   Linear_Scan_Busy_nextA <= 1'b0;
                                   CMD_reg_nextA <= 1'b0;
                              end
                         default : 
                              begin
                                   i_nextA <= 5'd0;
                                   TH_reg_nextA <= 10'd0;
                                   BL_int_nextA <= 10'd0;
                                   SAR_Scan_Busy_nextA <= 1'b0;
                                   SAR_Scan_Done_nextA <= 1'b0;
                                   Linear_Scan_Busy_nextA <= 1'b0;
                                   CMD_reg_nextA <= 1'b0;
                              end
                    endcase
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB||BypassB)
               begin
                    i_nextB <= 5'd0;
                    TH_reg_nextB <= 10'd0;
                    BL_int_nextB <= 10'd0;
                    SAR_Scan_Busy_nextB <= 1'b0;
                    SAR_Scan_Done_nextB <= 1'b0;
                    Linear_Scan_Busy_nextB <= 1'b0;
                    CMD_reg_nextB <= 1'b0;
               end
          else
               begin
                    case (state_nextB)
                         INIT : 
                              begin
                                   i_nextB <= 5'd0;
                                   TH_reg_nextB <= 10'd0;
                                   BL_int_nextB <= 10'd0;
                                   SAR_Scan_Busy_nextB <= 1'b0;
                                   SAR_Scan_Done_nextB <= 1'b0;
                                   Linear_Scan_Busy_nextB <= 1'b0;
                                   CMD_reg_nextB <= 1'b0;
                              end
                         SAR_INIT : 
                              begin
                                   i_nextB <= 5'd1;
                                   TH_reg_nextB <= 10'b10_0000_0000;
                                   BL_int_nextB <= 10'd0;
                                   SAR_Scan_Busy_nextB <= 1'b0;
                                   SAR_Scan_Done_nextB <= 1'b0;
                                   Linear_Scan_Busy_nextB <= 1'b0;
                                   CMD_reg_nextB <= 1'b0;
                              end
                         SAR_SCAN : 
                              begin
                                   if (iVotedB<5'd9&&counter_clkB==T1mS)
                                        begin
                                             i_nextB <= iVotedB+1'b1;
                                             if (BLAccB>2048)
                                                  TH_reg_nextB[10-iVotedB]  <= 1'b1;
                                             else
                                                  TH_reg_nextB[10-iVotedB]  <= 1'b0;
                                             TH_reg_nextB[9-iVotedB]  <= 1'b1;
                                        end
                                   else
                                        if (iVotedB==5'd9&&counter_clkB==T1mS)
                                             begin
                                                  i_nextB <= iVotedB+1'b1;
                                                  if (BLAccB>2048)
                                                       TH_reg_nextB[0]  <= 1'b1;
                                                  else
                                                       TH_reg_nextB[0]  <= 1'b0;
                                             end
                                   BL_int_nextB <= 10'd0;
                                   SAR_Scan_Busy_nextB <= 1'b1;
                                   SAR_Scan_Done_nextB <= 1'b0;
                                   Linear_Scan_Busy_nextB <= 1'b0;
                                   if (counter_clkB==T50uS)
                                        CMD_reg_nextB <= 1'b1;
                                   else
                                        if (counter_clkB==T50p05uS)
                                             CMD_reg_nextB <= 1'b0;
                              end
                         SAR_DONE : 
                              begin
                                   i_nextB <= 5'd0;
                                   TH_reg_nextB <= TH_regVotedB;
                                   BL_int_nextB <= TH_regVotedB;
                                   SAR_Scan_Busy_nextB <= 1'b0;
                                   SAR_Scan_Done_nextB <= 1'b1;
                                   Linear_Scan_Busy_nextB <= 1'b0;
                                   CMD_reg_nextB <= 1'b0;
                              end
                         LINEAR_INIT : 
                              begin
                                   i_nextB <= 5'd1;
                                   TH_reg_nextB <= TH_regVotedB-10'd12;
                                   BL_int_nextB <= TH_regVotedB;
                                   SAR_Scan_Busy_nextB <= 1'b0;
                                   SAR_Scan_Done_nextB <= 1'b1;
                                   Linear_Scan_Busy_nextB <= 1'b0;
                                   CMD_reg_nextB <= 1'b0;
                              end
                         LINEAR_SCAN : 
                              begin
                                   if (iVotedB<5'd25&&counter_clkB==T1mS)
                                        begin
                                             i_nextB <= iVotedB+1'b1;
                                             TH_reg_nextB <= TH_regVotedB+1'b1;
                                        end
                                   BL_int_nextB <= BL_intVotedB;
                                   SAR_Scan_Busy_nextB <= 1'b0;
                                   SAR_Scan_Done_nextB <= 1'b0;
                                   Linear_Scan_Busy_nextB <= 1'b1;
                                   if (counter_clkB==T50uS)
                                        CMD_reg_nextB <= 1'b1;
                                   else
                                        if (counter_clkB==T50p05uS)
                                             CMD_reg_nextB <= 1'b0;
                              end
                         IDLE : 
                              begin
                                   i_nextB <= 5'd0;
                                   TH_reg_nextB <= TH_regVotedB;
                                   BL_int_nextB <= BL_intVotedB;
                                   SAR_Scan_Busy_nextB <= 1'b0;
                                   SAR_Scan_Done_nextB <= 1'b0;
                                   Linear_Scan_Busy_nextB <= 1'b0;
                                   CMD_reg_nextB <= 1'b0;
                              end
                         default : 
                              begin
                                   i_nextB <= 5'd0;
                                   TH_reg_nextB <= 10'd0;
                                   BL_int_nextB <= 10'd0;
                                   SAR_Scan_Busy_nextB <= 1'b0;
                                   SAR_Scan_Done_nextB <= 1'b0;
                                   Linear_Scan_Busy_nextB <= 1'b0;
                                   CMD_reg_nextB <= 1'b0;
                              end
                    endcase
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC||BypassC)
               begin
                    i_nextC <= 5'd0;
                    TH_reg_nextC <= 10'd0;
                    BL_int_nextC <= 10'd0;
                    SAR_Scan_Busy_nextC <= 1'b0;
                    SAR_Scan_Done_nextC <= 1'b0;
                    Linear_Scan_Busy_nextC <= 1'b0;
                    CMD_reg_nextC <= 1'b0;
               end
          else
               begin
                    case (state_nextC)
                         INIT : 
                              begin
                                   i_nextC <= 5'd0;
                                   TH_reg_nextC <= 10'd0;
                                   BL_int_nextC <= 10'd0;
                                   SAR_Scan_Busy_nextC <= 1'b0;
                                   SAR_Scan_Done_nextC <= 1'b0;
                                   Linear_Scan_Busy_nextC <= 1'b0;
                                   CMD_reg_nextC <= 1'b0;
                              end
                         SAR_INIT : 
                              begin
                                   i_nextC <= 5'd1;
                                   TH_reg_nextC <= 10'b10_0000_0000;
                                   BL_int_nextC <= 10'd0;
                                   SAR_Scan_Busy_nextC <= 1'b0;
                                   SAR_Scan_Done_nextC <= 1'b0;
                                   Linear_Scan_Busy_nextC <= 1'b0;
                                   CMD_reg_nextC <= 1'b0;
                              end
                         SAR_SCAN : 
                              begin
                                   if (iVotedC<5'd9&&counter_clkC==T1mS)
                                        begin
                                             i_nextC <= iVotedC+1'b1;
                                             if (BLAccC>2048)
                                                  TH_reg_nextC[10-iVotedC]  <= 1'b1;
                                             else
                                                  TH_reg_nextC[10-iVotedC]  <= 1'b0;
                                             TH_reg_nextC[9-iVotedC]  <= 1'b1;
                                        end
                                   else
                                        if (iVotedC==5'd9&&counter_clkC==T1mS)
                                             begin
                                                  i_nextC <= iVotedC+1'b1;
                                                  if (BLAccC>2048)
                                                       TH_reg_nextC[0]  <= 1'b1;
                                                  else
                                                       TH_reg_nextC[0]  <= 1'b0;
                                             end
                                   BL_int_nextC <= 10'd0;
                                   SAR_Scan_Busy_nextC <= 1'b1;
                                   SAR_Scan_Done_nextC <= 1'b0;
                                   Linear_Scan_Busy_nextC <= 1'b0;
                                   if (counter_clkC==T50uS)
                                        CMD_reg_nextC <= 1'b1;
                                   else
                                        if (counter_clkC==T50p05uS)
                                             CMD_reg_nextC <= 1'b0;
                              end
                         SAR_DONE : 
                              begin
                                   i_nextC <= 5'd0;
                                   TH_reg_nextC <= TH_regVotedC;
                                   BL_int_nextC <= TH_regVotedC;
                                   SAR_Scan_Busy_nextC <= 1'b0;
                                   SAR_Scan_Done_nextC <= 1'b1;
                                   Linear_Scan_Busy_nextC <= 1'b0;
                                   CMD_reg_nextC <= 1'b0;
                              end
                         LINEAR_INIT : 
                              begin
                                   i_nextC <= 5'd1;
                                   TH_reg_nextC <= TH_regVotedC-10'd12;
                                   BL_int_nextC <= TH_regVotedC;
                                   SAR_Scan_Busy_nextC <= 1'b0;
                                   SAR_Scan_Done_nextC <= 1'b1;
                                   Linear_Scan_Busy_nextC <= 1'b0;
                                   CMD_reg_nextC <= 1'b0;
                              end
                         LINEAR_SCAN : 
                              begin
                                   if (iVotedC<5'd25&&counter_clkC==T1mS)
                                        begin
                                             i_nextC <= iVotedC+1'b1;
                                             TH_reg_nextC <= TH_regVotedC+1'b1;
                                        end
                                   BL_int_nextC <= BL_intVotedC;
                                   SAR_Scan_Busy_nextC <= 1'b0;
                                   SAR_Scan_Done_nextC <= 1'b0;
                                   Linear_Scan_Busy_nextC <= 1'b1;
                                   if (counter_clkC==T50uS)
                                        CMD_reg_nextC <= 1'b1;
                                   else
                                        if (counter_clkC==T50p05uS)
                                             CMD_reg_nextC <= 1'b0;
                              end
                         IDLE : 
                              begin
                                   i_nextC <= 5'd0;
                                   TH_reg_nextC <= TH_regVotedC;
                                   BL_int_nextC <= BL_intVotedC;
                                   SAR_Scan_Busy_nextC <= 1'b0;
                                   SAR_Scan_Done_nextC <= 1'b0;
                                   Linear_Scan_Busy_nextC <= 1'b0;
                                   CMD_reg_nextC <= 1'b0;
                              end
                         default : 
                              begin
                                   i_nextC <= 5'd0;
                                   TH_reg_nextC <= 10'd0;
                                   BL_int_nextC <= 10'd0;
                                   SAR_Scan_Busy_nextC <= 1'b0;
                                   SAR_Scan_Done_nextC <= 1'b0;
                                   Linear_Scan_Busy_nextC <= 1'b0;
                                   CMD_reg_nextC <= 1'b0;
                              end
                    endcase
               end
     end
reg  ScanActive_nextA;
reg  ScanActive_nextB;
reg  ScanActive_nextC;

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               ScanActiveA <= 1'b0;
          else
               begin
                    if (BypassA)
                         ScanActiveA <= 1'b0;
                    else
                         ScanActiveA <= ScanActive_nextA;
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               ScanActiveB <= 1'b0;
          else
               begin
                    if (BypassB)
                         ScanActiveB <= 1'b0;
                    else
                         ScanActiveB <= ScanActive_nextB;
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               ScanActiveC <= 1'b0;
          else
               begin
                    if (BypassC)
                         ScanActiveC <= 1'b0;
                    else
                         ScanActiveC <= ScanActive_nextC;
               end
     end

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               ScanActive_nextA <= 1'b0;
          else
               begin
                    if (BypassA)
                         ScanActive_nextA <= 1'b0;
                    else
                         begin
                              case (state_nextA)
                                   INIT : ScanActive_nextA <= 1'b1;
                                   SAR_INIT : ScanActive_nextA <= 1'b1;
                                   SAR_SCAN : ScanActive_nextA <= 1'b1;
                                   SAR_DONE : ScanActive_nextA <= 1'b1;
                                   LINEAR_INIT : ScanActive_nextA <= 1'b1;
                                   LINEAR_SCAN : ScanActive_nextA <= 1'b1;
                                   IDLE : ScanActive_nextA <= 1'b0;
                                   default : ScanActive_nextA <= 1'b0;
                              endcase
                         end
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               ScanActive_nextB <= 1'b0;
          else
               begin
                    if (BypassB)
                         ScanActive_nextB <= 1'b0;
                    else
                         begin
                              case (state_nextB)
                                   INIT : ScanActive_nextB <= 1'b1;
                                   SAR_INIT : ScanActive_nextB <= 1'b1;
                                   SAR_SCAN : ScanActive_nextB <= 1'b1;
                                   SAR_DONE : ScanActive_nextB <= 1'b1;
                                   LINEAR_INIT : ScanActive_nextB <= 1'b1;
                                   LINEAR_SCAN : ScanActive_nextB <= 1'b1;
                                   IDLE : ScanActive_nextB <= 1'b0;
                                   default : ScanActive_nextB <= 1'b0;
                              endcase
                         end
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               ScanActive_nextC <= 1'b0;
          else
               begin
                    if (BypassC)
                         ScanActive_nextC <= 1'b0;
                    else
                         begin
                              case (state_nextC)
                                   INIT : ScanActive_nextC <= 1'b1;
                                   SAR_INIT : ScanActive_nextC <= 1'b1;
                                   SAR_SCAN : ScanActive_nextC <= 1'b1;
                                   SAR_DONE : ScanActive_nextC <= 1'b1;
                                   LINEAR_INIT : ScanActive_nextC <= 1'b1;
                                   LINEAR_SCAN : ScanActive_nextC <= 1'b1;
                                   IDLE : ScanActive_nextC <= 1'b0;
                                   default : ScanActive_nextC <= 1'b0;
                              endcase
                         end
               end
     end
reg  Auto_Scan_Done_nextA;
reg  Auto_Scan_Done_nextB;
reg  Auto_Scan_Done_nextC;

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               Auto_Scan_DoneA <= 1'b0;
          else
               begin
                    if (BypassA)
                         Auto_Scan_DoneA <= 1'b0;
                    else
                         Auto_Scan_DoneA <= Auto_Scan_Done_nextA;
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               Auto_Scan_DoneB <= 1'b0;
          else
               begin
                    if (BypassB)
                         Auto_Scan_DoneB <= 1'b0;
                    else
                         Auto_Scan_DoneB <= Auto_Scan_Done_nextB;
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               Auto_Scan_DoneC <= 1'b0;
          else
               begin
                    if (BypassC)
                         Auto_Scan_DoneC <= 1'b0;
                    else
                         Auto_Scan_DoneC <= Auto_Scan_Done_nextC;
               end
     end

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               Auto_Scan_Done_nextA <= 1'b0;
          else
               begin
                    if (BypassA)
                         Auto_Scan_Done_nextA <= 1'b0;
                    else
                         begin
                              case (state_nextA)
                                   INIT : Auto_Scan_Done_nextA <= 1'b0;
                                   SAR_INIT : Auto_Scan_Done_nextA <= 1'b0;
                                   SAR_SCAN : Auto_Scan_Done_nextA <= 1'b0;
                                   SAR_DONE : Auto_Scan_Done_nextA <= 1'b0;
                                   LINEAR_INIT : Auto_Scan_Done_nextA <= 1'b0;
                                   LINEAR_SCAN : Auto_Scan_Done_nextA <= 1'b0;
                                   IDLE : Auto_Scan_Done_nextA <= 1'b1;
                                   default : Auto_Scan_Done_nextA <= 1'b0;
                              endcase
                         end
               end
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               Auto_Scan_Done_nextB <= 1'b0;
          else
               begin
                    if (BypassB)
                         Auto_Scan_Done_nextB <= 1'b0;
                    else
                         begin
                              case (state_nextB)
                                   INIT : Auto_Scan_Done_nextB <= 1'b0;
                                   SAR_INIT : Auto_Scan_Done_nextB <= 1'b0;
                                   SAR_SCAN : Auto_Scan_Done_nextB <= 1'b0;
                                   SAR_DONE : Auto_Scan_Done_nextB <= 1'b0;
                                   LINEAR_INIT : Auto_Scan_Done_nextB <= 1'b0;
                                   LINEAR_SCAN : Auto_Scan_Done_nextB <= 1'b0;
                                   IDLE : Auto_Scan_Done_nextB <= 1'b1;
                                   default : Auto_Scan_Done_nextB <= 1'b0;
                              endcase
                         end
               end
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               Auto_Scan_Done_nextC <= 1'b0;
          else
               begin
                    if (BypassC)
                         Auto_Scan_Done_nextC <= 1'b0;
                    else
                         begin
                              case (state_nextC)
                                   INIT : Auto_Scan_Done_nextC <= 1'b0;
                                   SAR_INIT : Auto_Scan_Done_nextC <= 1'b0;
                                   SAR_SCAN : Auto_Scan_Done_nextC <= 1'b0;
                                   SAR_DONE : Auto_Scan_Done_nextC <= 1'b0;
                                   LINEAR_INIT : Auto_Scan_Done_nextC <= 1'b0;
                                   LINEAR_SCAN : Auto_Scan_Done_nextC <= 1'b0;
                                   IDLE : Auto_Scan_Done_nextC <= 1'b1;
                                   default : Auto_Scan_Done_nextC <= 1'b0;
                              endcase
                         end
               end
     end
reg  [3:0] NW_regA;
reg  [3:0] NW_regB;
reg  [3:0] NW_regC;
reg  [3:0] NW_reg_nextA;
reg  [3:0] NW_reg_nextB;
reg  [3:0] NW_reg_nextC;

always @( posedge clkGatedA or posedge porA )
     begin
          if (porA)
               NW_regA <= 1'b0;
          else
               NW_regA <= NW_reg_nextA;
     end

always @( posedge clkGatedB or posedge porB )
     begin
          if (porB)
               NW_regB <= 1'b0;
          else
               NW_regB <= NW_reg_nextB;
     end

always @( posedge clkGatedC or posedge porC )
     begin
          if (porC)
               NW_regC <= 1'b0;
          else
               NW_regC <= NW_reg_nextC;
     end

always @( posedge clkGatedA or posedge porA )
     begin
          if (porA)
               NW_reg_nextA <= 1'b0;
          else
               begin
                    if (!Auto_Scan_DoneVotedA)
                         begin
                              if (H2L_BLScan_BusyA)
                                   begin
                                        if (SAR_Scan_BusyVotedA||BypassA)
                                             NW_reg_nextA <= 1'b0;
                                        else
                                             if (Linear_Scan_BusyVotedA==1&&BLAccA>0&&BLAccA<32768)
                                                  NW_reg_nextA <= NW_regVotedA+NoiseFlagA;
                                   end
                         end
                    else
                         NW_reg_nextA <= NW_regVotedA;
               end
     end

always @( posedge clkGatedB or posedge porB )
     begin
          if (porB)
               NW_reg_nextB <= 1'b0;
          else
               begin
                    if (!Auto_Scan_DoneVotedB)
                         begin
                              if (H2L_BLScan_BusyB)
                                   begin
                                        if (SAR_Scan_BusyVotedB||BypassB)
                                             NW_reg_nextB <= 1'b0;
                                        else
                                             if (Linear_Scan_BusyVotedB==1&&BLAccB>0&&BLAccB<32768)
                                                  NW_reg_nextB <= NW_regVotedB+NoiseFlagB;
                                   end
                         end
                    else
                         NW_reg_nextB <= NW_regVotedB;
               end
     end

always @( posedge clkGatedC or posedge porC )
     begin
          if (porC)
               NW_reg_nextC <= 1'b0;
          else
               begin
                    if (!Auto_Scan_DoneVotedC)
                         begin
                              if (H2L_BLScan_BusyC)
                                   begin
                                        if (SAR_Scan_BusyVotedC||BypassC)
                                             NW_reg_nextC <= 1'b0;
                                        else
                                             if (Linear_Scan_BusyVotedC==1&&BLAccC>0&&BLAccC<32768)
                                                  NW_reg_nextC <= NW_regVotedC+NoiseFlagC;
                                   end
                         end
                    else
                         NW_reg_nextC <= NW_regVotedC;
               end
     end
reg  [9:0] BL_regA;
reg  [9:0] BL_regB;
reg  [9:0] BL_regC;
reg  [9:0] BL_reg_nextA;
reg  [9:0] BL_reg_nextB;
reg  [9:0] BL_reg_nextC;
reg  [`AccumulatorBit-2:0] DiffAccA;
reg  [`AccumulatorBit-2:0] DiffAccB;
reg  [`AccumulatorBit-2:0] DiffAccC;
reg  [`AccumulatorBit-2:0] DiffAcc_preA;
reg  [`AccumulatorBit-2:0] DiffAcc_preB;
reg  [`AccumulatorBit-2:0] DiffAcc_preC;

always @( posedge clkGatedA or posedge porA )
     begin
          if (porA)
               BL_regA <= 1'b0;
          else
               BL_regA <= BL_reg_nextA;
     end

always @( posedge clkGatedB or posedge porB )
     begin
          if (porB)
               BL_regB <= 1'b0;
          else
               BL_regB <= BL_reg_nextB;
     end

always @( posedge clkGatedC or posedge porC )
     begin
          if (porC)
               BL_regC <= 1'b0;
          else
               BL_regC <= BL_reg_nextC;
     end

always @( posedge clkGatedA or posedge porA )
     begin
          if (porA)
               begin
                    DiffAcc_preA <= 15'd0;
                    DiffAccA <= 15'd0;
                    BL_reg_nextA <= 10'd0;
               end
          else
               begin
                    if (!Auto_Scan_DoneVotedA)
                         begin
                              if (H2L_BLScan_BusyA)
                                   begin
                                        if (SAR_Scan_BusyVotedA||BypassA)
                                             begin
                                                  DiffAcc_preA <= 15'd0;
                                                  DiffAccA <= 15'd0;
                                                  BL_reg_nextA <= 10'd0;
                                             end
                                        else
                                             if (Linear_Scan_BusyVotedA==1)
                                                  begin
                                                       DiffAcc_preA <= DiffAccA;
                                                       if (BLAccA>=2048)
                                                            DiffAccA <= BLAccA-2048;
                                                       else
                                                            DiffAccA <= 2048-BLAccA;
                                                       if (DiffAccA<DiffAcc_preA)
                                                            BL_reg_nextA <= TH_regVotedA;
                                                  end
                                   end
                         end
                    else
                         BL_reg_nextA <= BL_regVotedA;
               end
     end

always @( posedge clkGatedB or posedge porB )
     begin
          if (porB)
               begin
                    DiffAcc_preB <= 15'd0;
                    DiffAccB <= 15'd0;
                    BL_reg_nextB <= 10'd0;
               end
          else
               begin
                    if (!Auto_Scan_DoneVotedB)
                         begin
                              if (H2L_BLScan_BusyB)
                                   begin
                                        if (SAR_Scan_BusyVotedB||BypassB)
                                             begin
                                                  DiffAcc_preB <= 15'd0;
                                                  DiffAccB <= 15'd0;
                                                  BL_reg_nextB <= 10'd0;
                                             end
                                        else
                                             if (Linear_Scan_BusyVotedB==1)
                                                  begin
                                                       DiffAcc_preB <= DiffAccB;
                                                       if (BLAccB>=2048)
                                                            DiffAccB <= BLAccB-2048;
                                                       else
                                                            DiffAccB <= 2048-BLAccB;
                                                       if (DiffAccB<DiffAcc_preB)
                                                            BL_reg_nextB <= TH_regVotedB;
                                                  end
                                   end
                         end
                    else
                         BL_reg_nextB <= BL_regVotedB;
               end
     end

always @( posedge clkGatedC or posedge porC )
     begin
          if (porC)
               begin
                    DiffAcc_preC <= 15'd0;
                    DiffAccC <= 15'd0;
                    BL_reg_nextC <= 10'd0;
               end
          else
               begin
                    if (!Auto_Scan_DoneVotedC)
                         begin
                              if (H2L_BLScan_BusyC)
                                   begin
                                        if (SAR_Scan_BusyVotedC||BypassC)
                                             begin
                                                  DiffAcc_preC <= 15'd0;
                                                  DiffAccC <= 15'd0;
                                                  BL_reg_nextC <= 10'd0;
                                             end
                                        else
                                             if (Linear_Scan_BusyVotedC==1)
                                                  begin
                                                       DiffAcc_preC <= DiffAccC;
                                                       if (BLAccC>=2048)
                                                            DiffAccC <= BLAccC-2048;
                                                       else
                                                            DiffAccC <= 2048-BLAccC;
                                                       if (DiffAccC<DiffAcc_preC)
                                                            BL_reg_nextC <= TH_regVotedC;
                                                  end
                                   end
                         end
                    else
                         BL_reg_nextC <= BL_regVotedC;
               end
     end
reg  ministateA;
reg  ministateB;
reg  ministateC;
reg  ministate_nextA;
reg  ministate_nextB;
reg  ministate_nextC;

always @( posedge clkGatedA )
     begin
          if (!resetnA)
               ministateA <= 1'b1;
          else
               ministateA <= ministate_nextA;
     end

always @( posedge clkGatedB )
     begin
          if (!resetnB)
               ministateB <= 1'b1;
          else
               ministateB <= ministate_nextB;
     end

always @( posedge clkGatedC )
     begin
          if (!resetnC)
               ministateC <= 1'b1;
          else
               ministateC <= ministate_nextC;
     end

always @( * )
     begin
          case (ministateVotedA)
               1'b0 : 
                    begin
                         if (Auto_Scan_Done_nextA)
                              ministate_nextA <= 1'b1;
                         else
                              ministate_nextA <= 1'b0;
                    end
               1'b1 : 
                    begin
                         if (L2H_ScanStartA)
                              ministate_nextA <= 1'b0;
                         else
                              ministate_nextA <= 1'b1;
                    end
               default : ministateA <= 1'b1;
          endcase
     end

always @( * )
     begin
          case (ministateVotedB)
               1'b0 : 
                    begin
                         if (Auto_Scan_Done_nextB)
                              ministate_nextB <= 1'b1;
                         else
                              ministate_nextB <= 1'b0;
                    end
               1'b1 : 
                    begin
                         if (L2H_ScanStartB)
                              ministate_nextB <= 1'b0;
                         else
                              ministate_nextB <= 1'b1;
                    end
               default : ministateB <= 1'b1;
          endcase
     end

always @( * )
     begin
          case (ministateVotedC)
               1'b0 : 
                    begin
                         if (Auto_Scan_Done_nextC)
                              ministate_nextC <= 1'b1;
                         else
                              ministate_nextC <= 1'b0;
                    end
               1'b1 : 
                    begin
                         if (L2H_ScanStartC)
                              ministate_nextC <= 1'b0;
                         else
                              ministate_nextC <= 1'b1;
                    end
               default : ministateC <= 1'b1;
          endcase
     end
assign BL =  BL_regVoted;
assign NW =  NW_regVoted;
assign TH =  (Bypass) ? DAC : ((ministateVoted) ? (BL+TH_offset) : TH_regVoted);
assign Acc =  (Bypass) ? BLAcc : 16'd0;
assign ScanDone =  (Bypass) ? SS_Scan_Done : Auto_Scan_DoneVoted;
assign StateOut =  stateVoted;

majorityVoter #(.WIDTH(10)) BL_regVotedVoter (
          .inA(BL_regVotedA),
          .inB(BL_regVotedB),
          .inC(BL_regVotedC),
          .out(BL_regVoted),
          .tmrErr(BL_regVotedTmrError)
          );

majorityVoter ministateVotedVoter (
          .inA(ministateVotedA),
          .inB(ministateVotedB),
          .inC(ministateVotedC),
          .out(ministateVoted),
          .tmrErr(ministateVotedTmrError)
          );

majorityVoter SS_Scan_DoneVoter (
          .inA(SS_Scan_DoneA),
          .inB(SS_Scan_DoneB),
          .inC(SS_Scan_DoneC),
          .out(SS_Scan_Done),
          .tmrErr(SS_Scan_DoneTmrError)
          );

majorityVoter #(.WIDTH(((`AccumulatorBit-1)>(0)) ? ((`AccumulatorBit-1)-(0)+1) : ((0)-(`AccumulatorBit-1)+1))) BLAccVoter (
          .inA(BLAccA),
          .inB(BLAccB),
          .inC(BLAccC),
          .out(BLAcc),
          .tmrErr(BLAccTmrError)
          );

majorityVoter Auto_Scan_DoneVotedVoter (
          .inA(Auto_Scan_DoneVotedA),
          .inB(Auto_Scan_DoneVotedB),
          .inC(Auto_Scan_DoneVotedC),
          .out(Auto_Scan_DoneVoted),
          .tmrErr(Auto_Scan_DoneVotedTmrError)
          );

majorityVoter #(.WIDTH(3)) stateVotedVoter (
          .inA(stateVotedA),
          .inB(stateVotedB),
          .inC(stateVotedC),
          .out(stateVoted),
          .tmrErr(stateVotedTmrError)
          );

majorityVoter #(.WIDTH(4)) NW_regVotedVoter (
          .inA(NW_regVotedA),
          .inB(NW_regVotedB),
          .inC(NW_regVotedC),
          .out(NW_regVoted),
          .tmrErr(NW_regVotedTmrError)
          );

majorityVoter #(.WIDTH(10)) TH_regVotedVoter (
          .inA(TH_regVotedA),
          .inB(TH_regVotedB),
          .inC(TH_regVotedC),
          .out(TH_regVoted),
          .tmrErr(TH_regVotedTmrError)
          );
assign tmrError =  Auto_Scan_DoneVotedTmrError|BLAccTmrError|BL_regVotedTmrError|NW_regVotedTmrError|SS_Scan_DoneTmrError|TH_regVotedTmrError|ministateVotedTmrError|stateVotedTmrError;

majorityVoter ScanActiveVoterA (
          .inA(ScanActiveA),
          .inB(ScanActiveB),
          .inC(ScanActiveC),
          .out(ScanActiveVotedA),
          .tmrErr(ScanActiveTmrErrorA)
          );

majorityVoter SAR_Scan_BusyVoterA (
          .inA(SAR_Scan_BusyA),
          .inB(SAR_Scan_BusyB),
          .inC(SAR_Scan_BusyC),
          .out(SAR_Scan_BusyVotedA),
          .tmrErr(SAR_Scan_BusyTmrErrorA)
          );

majorityVoter Auto_Scan_DoneVoterA (
          .inA(Auto_Scan_DoneA),
          .inB(Auto_Scan_DoneB),
          .inC(Auto_Scan_DoneC),
          .out(Auto_Scan_DoneVotedA),
          .tmrErr(Auto_Scan_DoneTmrErrorA)
          );

majorityVoter #(.WIDTH(4)) NW_regVoterA (
          .inA(NW_regA),
          .inB(NW_regB),
          .inC(NW_regC),
          .out(NW_regVotedA),
          .tmrErr(NW_regTmrErrorA)
          );

majorityVoter #(.WIDTH(10)) BL_regVoterA (
          .inA(BL_regA),
          .inB(BL_regB),
          .inC(BL_regC),
          .out(BL_regVotedA),
          .tmrErr(BL_regTmrErrorA)
          );

majorityVoter #(.WIDTH(10)) TH_regVoterA (
          .inA(TH_regA),
          .inB(TH_regB),
          .inC(TH_regC),
          .out(TH_regVotedA),
          .tmrErr(TH_regTmrErrorA)
          );

majorityVoter #(.WIDTH(5)) iVoterA (
          .inA(iA),
          .inB(iB),
          .inC(iC),
          .out(iVotedA),
          .tmrErr(iTmrErrorA)
          );

majorityVoter SAR_Scan_DoneVoterA (
          .inA(SAR_Scan_DoneA),
          .inB(SAR_Scan_DoneB),
          .inC(SAR_Scan_DoneC),
          .out(SAR_Scan_DoneVotedA),
          .tmrErr(SAR_Scan_DoneTmrErrorA)
          );

majorityVoter CMD_regVoterA (
          .inA(CMD_regA),
          .inB(CMD_regB),
          .inC(CMD_regC),
          .out(CMD_regVotedA),
          .tmrErr(CMD_regTmrErrorA)
          );

majorityVoter Linear_Scan_BusyVoterA (
          .inA(Linear_Scan_BusyA),
          .inB(Linear_Scan_BusyB),
          .inC(Linear_Scan_BusyC),
          .out(Linear_Scan_BusyVotedA),
          .tmrErr(Linear_Scan_BusyTmrErrorA)
          );

majorityVoter #(.WIDTH(10)) BL_intVoterA (
          .inA(BL_intA),
          .inB(BL_intB),
          .inC(BL_intC),
          .out(BL_intVotedA),
          .tmrErr(BL_intTmrErrorA)
          );

majorityVoter ministateVoterA (
          .inA(ministateA),
          .inB(ministateB),
          .inC(ministateC),
          .out(ministateVotedA),
          .tmrErr(ministateTmrErrorA)
          );

majorityVoter #(.WIDTH(3)) stateVoterA (
          .inA(stateA),
          .inB(stateB),
          .inC(stateC),
          .out(stateVotedA),
          .tmrErr(stateTmrErrorA)
          );
assign tmrErrorA =  Auto_Scan_DoneTmrErrorA|BL_intTmrErrorA|BL_regTmrErrorA|CMD_regTmrErrorA|Linear_Scan_BusyTmrErrorA|NW_regTmrErrorA|PulGen_Done_InsttmrErrorA|SAR_Scan_BusyTmrErrorA|SAR_Scan_DoneTmrErrorA|ScanActiveTmrErrorA|TH_regTmrErrorA|bl_scan_InsttmrErrorA|iTmrErrorA|ministateTmrErrorA|stateTmrErrorA;

majorityVoter ScanActiveVoterB (
          .inA(ScanActiveA),
          .inB(ScanActiveB),
          .inC(ScanActiveC),
          .out(ScanActiveVotedB),
          .tmrErr(ScanActiveTmrErrorB)
          );

majorityVoter SAR_Scan_BusyVoterB (
          .inA(SAR_Scan_BusyA),
          .inB(SAR_Scan_BusyB),
          .inC(SAR_Scan_BusyC),
          .out(SAR_Scan_BusyVotedB),
          .tmrErr(SAR_Scan_BusyTmrErrorB)
          );

majorityVoter Auto_Scan_DoneVoterB (
          .inA(Auto_Scan_DoneA),
          .inB(Auto_Scan_DoneB),
          .inC(Auto_Scan_DoneC),
          .out(Auto_Scan_DoneVotedB),
          .tmrErr(Auto_Scan_DoneTmrErrorB)
          );

majorityVoter #(.WIDTH(10)) BL_regVoterB (
          .inA(BL_regA),
          .inB(BL_regB),
          .inC(BL_regC),
          .out(BL_regVotedB),
          .tmrErr(BL_regTmrErrorB)
          );

majorityVoter #(.WIDTH(4)) NW_regVoterB (
          .inA(NW_regA),
          .inB(NW_regB),
          .inC(NW_regC),
          .out(NW_regVotedB),
          .tmrErr(NW_regTmrErrorB)
          );

majorityVoter #(.WIDTH(5)) iVoterB (
          .inA(iA),
          .inB(iB),
          .inC(iC),
          .out(iVotedB),
          .tmrErr(iTmrErrorB)
          );

majorityVoter #(.WIDTH(10)) TH_regVoterB (
          .inA(TH_regA),
          .inB(TH_regB),
          .inC(TH_regC),
          .out(TH_regVotedB),
          .tmrErr(TH_regTmrErrorB)
          );

majorityVoter #(.WIDTH(10)) BL_intVoterB (
          .inA(BL_intA),
          .inB(BL_intB),
          .inC(BL_intC),
          .out(BL_intVotedB),
          .tmrErr(BL_intTmrErrorB)
          );

majorityVoter Linear_Scan_BusyVoterB (
          .inA(Linear_Scan_BusyA),
          .inB(Linear_Scan_BusyB),
          .inC(Linear_Scan_BusyC),
          .out(Linear_Scan_BusyVotedB),
          .tmrErr(Linear_Scan_BusyTmrErrorB)
          );

majorityVoter CMD_regVoterB (
          .inA(CMD_regA),
          .inB(CMD_regB),
          .inC(CMD_regC),
          .out(CMD_regVotedB),
          .tmrErr(CMD_regTmrErrorB)
          );

majorityVoter #(.WIDTH(3)) stateVoterB (
          .inA(stateA),
          .inB(stateB),
          .inC(stateC),
          .out(stateVotedB),
          .tmrErr(stateTmrErrorB)
          );

majorityVoter SAR_Scan_DoneVoterB (
          .inA(SAR_Scan_DoneA),
          .inB(SAR_Scan_DoneB),
          .inC(SAR_Scan_DoneC),
          .out(SAR_Scan_DoneVotedB),
          .tmrErr(SAR_Scan_DoneTmrErrorB)
          );

majorityVoter ministateVoterB (
          .inA(ministateA),
          .inB(ministateB),
          .inC(ministateC),
          .out(ministateVotedB),
          .tmrErr(ministateTmrErrorB)
          );
assign tmrErrorB =  Auto_Scan_DoneTmrErrorB|BL_intTmrErrorB|BL_regTmrErrorB|CMD_regTmrErrorB|Linear_Scan_BusyTmrErrorB|NW_regTmrErrorB|PulGen_Done_InsttmrErrorB|SAR_Scan_BusyTmrErrorB|SAR_Scan_DoneTmrErrorB|ScanActiveTmrErrorB|TH_regTmrErrorB|bl_scan_InsttmrErrorB|iTmrErrorB|ministateTmrErrorB|stateTmrErrorB;

majorityVoter ScanActiveVoterC (
          .inA(ScanActiveA),
          .inB(ScanActiveB),
          .inC(ScanActiveC),
          .out(ScanActiveVotedC),
          .tmrErr(ScanActiveTmrErrorC)
          );

majorityVoter Auto_Scan_DoneVoterC (
          .inA(Auto_Scan_DoneA),
          .inB(Auto_Scan_DoneB),
          .inC(Auto_Scan_DoneC),
          .out(Auto_Scan_DoneVotedC),
          .tmrErr(Auto_Scan_DoneTmrErrorC)
          );

majorityVoter SAR_Scan_BusyVoterC (
          .inA(SAR_Scan_BusyA),
          .inB(SAR_Scan_BusyB),
          .inC(SAR_Scan_BusyC),
          .out(SAR_Scan_BusyVotedC),
          .tmrErr(SAR_Scan_BusyTmrErrorC)
          );

majorityVoter SAR_Scan_DoneVoterC (
          .inA(SAR_Scan_DoneA),
          .inB(SAR_Scan_DoneB),
          .inC(SAR_Scan_DoneC),
          .out(SAR_Scan_DoneVotedC),
          .tmrErr(SAR_Scan_DoneTmrErrorC)
          );

majorityVoter #(.WIDTH(10)) BL_regVoterC (
          .inA(BL_regA),
          .inB(BL_regB),
          .inC(BL_regC),
          .out(BL_regVotedC),
          .tmrErr(BL_regTmrErrorC)
          );

majorityVoter #(.WIDTH(4)) NW_regVoterC (
          .inA(NW_regA),
          .inB(NW_regB),
          .inC(NW_regC),
          .out(NW_regVotedC),
          .tmrErr(NW_regTmrErrorC)
          );

majorityVoter #(.WIDTH(10)) TH_regVoterC (
          .inA(TH_regA),
          .inB(TH_regB),
          .inC(TH_regC),
          .out(TH_regVotedC),
          .tmrErr(TH_regTmrErrorC)
          );

majorityVoter #(.WIDTH(5)) iVoterC (
          .inA(iA),
          .inB(iB),
          .inC(iC),
          .out(iVotedC),
          .tmrErr(iTmrErrorC)
          );

majorityVoter Linear_Scan_BusyVoterC (
          .inA(Linear_Scan_BusyA),
          .inB(Linear_Scan_BusyB),
          .inC(Linear_Scan_BusyC),
          .out(Linear_Scan_BusyVotedC),
          .tmrErr(Linear_Scan_BusyTmrErrorC)
          );

majorityVoter #(.WIDTH(10)) BL_intVoterC (
          .inA(BL_intA),
          .inB(BL_intB),
          .inC(BL_intC),
          .out(BL_intVotedC),
          .tmrErr(BL_intTmrErrorC)
          );

majorityVoter CMD_regVoterC (
          .inA(CMD_regA),
          .inB(CMD_regB),
          .inC(CMD_regC),
          .out(CMD_regVotedC),
          .tmrErr(CMD_regTmrErrorC)
          );

majorityVoter #(.WIDTH(3)) stateVoterC (
          .inA(stateA),
          .inB(stateB),
          .inC(stateC),
          .out(stateVotedC),
          .tmrErr(stateTmrErrorC)
          );

majorityVoter ministateVoterC (
          .inA(ministateA),
          .inB(ministateB),
          .inC(ministateC),
          .out(ministateVotedC),
          .tmrErr(ministateTmrErrorC)
          );
assign tmrErrorC =  Auto_Scan_DoneTmrErrorC|BL_intTmrErrorC|BL_regTmrErrorC|CMD_regTmrErrorC|Linear_Scan_BusyTmrErrorC|NW_regTmrErrorC|PulGen_Done_InsttmrErrorC|SAR_Scan_BusyTmrErrorC|SAR_Scan_DoneTmrErrorC|ScanActiveTmrErrorC|TH_regTmrErrorC|bl_scan_InsttmrErrorC|iTmrErrorC|ministateTmrErrorC|stateTmrErrorC;

fanout RSTnFanout (
          .in(RSTn),
          .outA(RSTnA),
          .outB(RSTnB),
          .outC(RSTnC)
          );

fanout ScanStartFanout (
          .in(ScanStart),
          .outA(ScanStartA),
          .outB(ScanStartB),
          .outC(ScanStartC)
          );

fanout BypassFanout (
          .in(Bypass),
          .outA(BypassA),
          .outB(BypassB),
          .outC(BypassC)
          );

fanout CLKEnFanout (
          .in(CLKEn),
          .outA(CLKEnA),
          .outB(CLKEnB),
          .outC(CLKEnC)
          );

fanout DiscriPulFanout (
          .in(DiscriPul),
          .outA(DiscriPulA),
          .outB(DiscriPulB),
          .outC(DiscriPulC)
          );

fanout CLKFanout (
          .in(CLK),
          .outA(CLKA),
          .outB(CLKB),
          .outC(CLKC)
          );

fanout ScanDoneFanout (
          .in(ScanDone),
          .outA(ScanDoneA),
          .outB(ScanDoneB),
          .outC(ScanDoneC)
          );
endmodule

module PulGen_StartTMR(
     input  ScanStartA,
     input  ScanStartB,
     input  ScanStartC,
     output  L2H_ScanStartA,
     output  L2H_ScanStartB,
     output  L2H_ScanStartC
);
parameter    DelayElement_SS=40;
// wire L2H_ScanStartA;
// wire L2H_ScanStartB;
// wire L2H_ScanStartC;
wire [DelayElement_SS:0] ScanStart_DLA;
wire [DelayElement_SS:0] ScanStart_DLB;
wire [DelayElement_SS:0] ScanStart_DLC;
assign ScanStart_DLA[0]  =  ScanStartA;
assign ScanStart_DLB[0]  =  ScanStartB;
assign ScanStart_DLC[0]  =  ScanStartC;
genvar k;

generate
     for(k =  0;k<DelayElement_SS;k =  k+1)
          begin : DEL_SS 

               DEL4WRAPPER_THCtrl delayCell_SSA (
                         .I(ScanStart_DLA[k] ),
                         .Z(ScanStart_DLA[k+1] )
                         );

               DEL4WRAPPER_THCtrl delayCell_SSB (
                         .I(ScanStart_DLB[k] ),
                         .Z(ScanStart_DLB[k+1] )
                         );

               DEL4WRAPPER_THCtrl delayCell_SSC (
                         .I(ScanStart_DLC[k] ),
                         .Z(ScanStart_DLC[k+1] )
                         );
          end

endgenerate
wire ScanStart_DLINVA;
wire ScanStart_DLINVB;
wire ScanStart_DLINVC;

INVD1 inv_SSA (
          .I(ScanStart_DLA[DelayElement_SS] ),
          .ZN(ScanStart_DLINVA)
          );

INVD1 inv_SSB (
          .I(ScanStart_DLB[DelayElement_SS] ),
          .ZN(ScanStart_DLINVB)
          );

INVD1 inv_SSC (
          .I(ScanStart_DLC[DelayElement_SS] ),
          .ZN(ScanStart_DLINVC)
          );

AN2D1 an2_SSA (
          .A1(ScanStartA),
          .A2(ScanStart_DLINVA),
          .Z(L2H_ScanStartA)
          );

AN2D1 an2_SSB (
          .A1(ScanStartB),
          .A2(ScanStart_DLINVB),
          .Z(L2H_ScanStartB)
          );

AN2D1 an2_SSC (
          .A1(ScanStartC),
          .A2(ScanStart_DLINVC),
          .Z(L2H_ScanStartC)
          );
endmodule

module PulGen_DoneTMR(
     input  CLKA,
     input  CLKB,
     input  CLKC,
     input  resetnA,
     input  resetnB,
     input  resetnC,
     input  ScanDoneA,
     input  ScanDoneB,
     input  ScanDoneC,
     output  L2H_ScanDoneA,
     output  L2H_ScanDoneB,
     output  L2H_ScanDoneC,
     output  tmrErrorA,
     output  tmrErrorB,
     output  tmrErrorC
);
wor ScanDone_regTmrErrorC;
wire ScanDone_regVotedC;
wor ScanDone_regTmrErrorB;
wire ScanDone_regVotedB;
wor ScanDone_regTmrErrorA;
wire ScanDone_regVotedA;
// wire L2H_ScanDoneA;
// wire L2H_ScanDoneB;
// wire L2H_ScanDoneC;
reg  ScanDone_regA;
reg  ScanDone_regB;
reg  ScanDone_regC;

always @( posedge CLKA )
     begin
          if (!resetnA)
               ScanDone_regA <= 0;
          else
               ScanDone_regA <= ScanDoneA;
     end

always @( posedge CLKB )
     begin
          if (!resetnB)
               ScanDone_regB <= 0;
          else
               ScanDone_regB <= ScanDoneB;
     end

always @( posedge CLKC )
     begin
          if (!resetnC)
               ScanDone_regC <= 0;
          else
               ScanDone_regC <= ScanDoneC;
     end
assign L2H_ScanDoneA =  (! ScanDone_regVotedA )&ScanDoneA;
assign L2H_ScanDoneB =  (! ScanDone_regVotedB )&ScanDoneB;
assign L2H_ScanDoneC =  (! ScanDone_regVotedC )&ScanDoneC;

majorityVoter ScanDone_regVoterA (
          .inA(ScanDone_regA),
          .inB(ScanDone_regB),
          .inC(ScanDone_regC),
          .out(ScanDone_regVotedA),
          .tmrErr(ScanDone_regTmrErrorA)
          );
assign tmrErrorA =  ScanDone_regTmrErrorA;

majorityVoter ScanDone_regVoterB (
          .inA(ScanDone_regA),
          .inB(ScanDone_regB),
          .inC(ScanDone_regC),
          .out(ScanDone_regVotedB),
          .tmrErr(ScanDone_regTmrErrorB)
          );
assign tmrErrorB =  ScanDone_regTmrErrorB;

majorityVoter ScanDone_regVoterC (
          .inA(ScanDone_regA),
          .inB(ScanDone_regB),
          .inC(ScanDone_regC),
          .out(ScanDone_regVotedC),
          .tmrErr(ScanDone_regTmrErrorC)
          );
assign tmrErrorC =  ScanDone_regTmrErrorC;
endmodule



// /users/qsun/workarea/tsmc65nm/ETROC_PLL/digital_work/tmrg/tmrg/../common/voter.v
module majorityVoter (inA, inB, inC, out, tmrErr);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   inA, inB, inC;
  output  [(WIDTH-1):0]   out;
  output                  tmrErr;
  reg                     tmrErr;
  assign out = (inA&inB) | (inA&inC) | (inB&inC);
  always @(inA or inB or inC)
  begin
    if (inA!=inB || inA!=inC || inB!=inC)
      tmrErr = 1;
    else
      tmrErr = 0;
  end
endmodule


// /users/qsun/workarea/tsmc65nm/ETROC_PLL/digital_work/tmrg/tmrg/../common/fanout.v
module fanout (in, outA, outB, outC);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   in;
  output  [(WIDTH-1):0]   outA,outB,outC;
  assign outA=in;
  assign outB=in;
  assign outC=in;
endmodule
