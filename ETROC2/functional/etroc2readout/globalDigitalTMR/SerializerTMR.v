/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./SerializerTMR.v                                                                      *
 *                                                                                                  *
 * user    : dtgong                                                                                 *
 * host    : sphy7asic01.smu.edu                                                                    *
 * date    : 26/04/2022 15:42:32                                                                    *
 *                                                                                                  *
 * workdir : /users/dtgong/workarea/tsmc65/ETLROC/digital/ETROC2Readout/gitlab/etroc2readout/tmpTMR *
 * cmd     : /users/qsun/workarea/tsmc65nm/ETROC_PLL/digital_work/tmrg/bin/tmrg ../Serializer.v     *
 *           ../serializerBlock.v ../PRBS7.v                                                        *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: ../Serializer.v                                                                        *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2022-04-26 15:39:47.342384                                         *
 *           File Size         : 8429                                                               *
 *           MD5 hash          : 40520377bba518881e55c4eccb86ac0f                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ns / 1ps
module serializerClockGenTMR(
  input  disA,
  input  disB,
  input  disC,
  input  clk1280A,
  input  clk1280B,
  input  clk1280C,
  input  clk40synA,
  input  clk40synB,
  input  clk40synC,
  output  clk40OutA,
  output  clk40OutB,
  output  clk40OutC,
  output  clk320OutA,
  output  clk320OutB,
  output  clk320OutC,
  output  clk640OutA,
  output  clk640OutB,
  output  clk640OutC,
  output  clk1280OutA,
  output  clk1280OutB,
  output  clk1280OutC,
  output  load40A,
  output  load40B,
  output  load40C,
  output  load640A,
  output  load640B,
  output  load640C,
  output  load1280A,
  output  load1280B,
  output  load1280C
);
localparam    rdClkPhase=5'b10000;
wor nextCounterTmrErrorC;
wire [4:0] nextCounterVotedC;
wor nextCounterTmrErrorB;
wire [4:0] nextCounterVotedB;
wor nextCounterTmrErrorA;
wire [4:0] nextCounterVotedA;
// wire load40A;
// wire load40B;
// wire load40C;
// wire load640A;
// wire load640B;
// wire load640C;
// wire load1280A;
// wire load1280B;
// wire load1280C;
wire resetA;
wire resetB;
wire resetC;
reg  [4:0] counterA;
reg  [4:0] counterB;
reg  [4:0] counterC;
reg  clk40syncLaterA;
reg  clk40syncLaterB;
reg  clk40syncLaterC;
reg  clk40syncLater1DA;
reg  clk40syncLater1DB;
reg  clk40syncLater1DC;
assign resetA =  ~(~ clk40syncLaterA & clk40syncLater1DA );
assign resetB =  ~(~ clk40syncLaterB & clk40syncLater1DB );
assign resetC =  ~(~ clk40syncLaterC & clk40syncLater1DC );
wire [4:0] nextCounterA =  counterA+1;
wire [4:0] nextCounterB =  counterB+1;
wire [4:0] nextCounterC =  counterC+1;

always @( posedge clk1280A )
  begin
    if (~disA)
      begin
        clk40syncLaterA <= clk40synA;
        clk40syncLater1DA <= clk40syncLaterA;
      end
    else
      begin
        clk40syncLaterA <= 1'b0;
        clk40syncLater1DA <= 1'b1;
      end
  end

always @( posedge clk1280B )
  begin
    if (~disB)
      begin
        clk40syncLaterB <= clk40synB;
        clk40syncLater1DB <= clk40syncLaterB;
      end
    else
      begin
        clk40syncLaterB <= 1'b0;
        clk40syncLater1DB <= 1'b1;
      end
  end

always @( posedge clk1280C )
  begin
    if (~disC)
      begin
        clk40syncLaterC <= clk40synC;
        clk40syncLater1DC <= clk40syncLaterC;
      end
    else
      begin
        clk40syncLaterC <= 1'b0;
        clk40syncLater1DC <= 1'b1;
      end
  end

always @( posedge clk1280A )
  begin
    if (~resetA)
      begin
        counterA <= rdClkPhase;
      end
    else
      begin
        counterA <= nextCounterVotedA;
      end
  end

always @( posedge clk1280B )
  begin
    if (~resetB)
      begin
        counterB <= rdClkPhase;
      end
    else
      begin
        counterB <= nextCounterVotedB;
      end
  end

always @( posedge clk1280C )
  begin
    if (~resetC)
      begin
        counterC <= rdClkPhase;
      end
    else
      begin
        counterC <= nextCounterVotedC;
      end
  end
assign clk1280OutA =  clk1280A;
assign clk1280OutB =  clk1280B;
assign clk1280OutC =  clk1280C;
assign clk640OutA =  counterA[0] ;
assign clk640OutB =  counterB[0] ;
assign clk640OutC =  counterC[0] ;
assign clk320OutA =  counterA[1] ;
assign clk320OutB =  counterB[1] ;
assign clk320OutC =  counterC[1] ;
assign clk40OutA =  counterA[4] ;
assign clk40OutB =  counterB[4] ;
assign clk40OutC =  counterC[4] ;
assign load40A =  ~counterA[4] &~counterA[3] &~counterA[2] ;
assign load40B =  ~counterB[4] &~counterB[3] &~counterB[2] ;
assign load40C =  ~counterC[4] &~counterC[3] &~counterC[2] ;
assign load640A =  ~clk320OutA;
assign load640B =  ~clk320OutB;
assign load640C =  ~clk320OutC;
assign load1280A =  ~clk640OutA;
assign load1280B =  ~clk640OutB;
assign load1280C =  ~clk640OutC;

majorityVoter #(.WIDTH(5)) nextCounterVoterA (
    .inA(nextCounterA),
    .inB(nextCounterB),
    .inC(nextCounterC),
    .out(nextCounterVotedA),
    .tmrErr(nextCounterTmrErrorA)
    );

majorityVoter #(.WIDTH(5)) nextCounterVoterB (
    .inA(nextCounterA),
    .inB(nextCounterB),
    .inC(nextCounterC),
    .out(nextCounterVotedB),
    .tmrErr(nextCounterTmrErrorB)
    );

majorityVoter #(.WIDTH(5)) nextCounterVoterC (
    .inA(nextCounterA),
    .inB(nextCounterB),
    .inC(nextCounterC),
    .out(nextCounterVotedC),
    .tmrErr(nextCounterTmrErrorC)
    );
endmodule

module serializerTMR(
  input  link_reset_refA,
  input  link_reset_refB,
  input  link_reset_refC,
  input  disA,
  input  disB,
  input  disC,
  input  link_reset_testPatternSelA,
  input  link_reset_testPatternSelB,
  input  link_reset_testPatternSelC,
  input [31:0] link_reset_fixedTestPatternA,
  input [31:0] link_reset_fixedTestPatternB,
  input [31:0] link_reset_fixedTestPatternC,
  input  clk1280A,
  input  clk1280B,
  input  clk1280C,
  input  clk40synA,
  input  clk40synB,
  input  clk40synC,
  input [1:0] rateA,
  input [1:0] rateB,
  input [1:0] rateC,
  input [31:0] dinA,
  input [31:0] dinB,
  input [31:0] dinC,
  output  sout
);
localparam    rdClkPhase=5'b10000;
wor soutMUXTmrError;
wire soutMUX;
reg  [31:0] dinRegA;
reg  [31:0] dinRegB;
reg  [31:0] dinRegC;

always @( negedge clk40synA )
  begin
    if (~disA)
      begin
        dinRegA <= dinA;
      end
    else
      begin
        dinRegA <= 32'd0;
      end
  end

always @( negedge clk40synB )
  begin
    if (~disB)
      begin
        dinRegB <= dinB;
      end
    else
      begin
        dinRegB <= 32'd0;
      end
  end

always @( negedge clk40synC )
  begin
    if (~disC)
      begin
        dinRegC <= dinC;
      end
    else
      begin
        dinRegC <= 32'd0;
      end
  end
wire testPatternSelA =  link_reset_testPatternSelA;
wire testPatternSelB =  link_reset_testPatternSelB;
wire testPatternSelC =  link_reset_testPatternSelC;
wire [31:0] fixedTestPatternA =  link_reset_fixedTestPatternA;
wire [31:0] fixedTestPatternB =  link_reset_fixedTestPatternB;
wire [31:0] fixedTestPatternC =  link_reset_fixedTestPatternC;
wire clk40OutA;
wire clk40OutB;
wire clk40OutC;
wire clk320OutA;
wire clk320OutB;
wire clk320OutC;
wire clk640OutA;
wire clk640OutB;
wire clk640OutC;
wire clk1280OutA;
wire clk1280OutB;
wire clk1280OutC;
wire load40A;
wire load40B;
wire load40C;
wire load640A;
wire load640B;
wire load640C;
wire load1280A;
wire load1280B;
wire load1280C;

serializerClockGenTMR clkgen (
    .disA(disA),
    .disB(disB),
    .disC(disC),
    .clk1280A(clk1280A),
    .clk1280B(clk1280B),
    .clk1280C(clk1280C),
    .clk40synA(clk40synA),
    .clk40synB(clk40synB),
    .clk40synC(clk40synC),
    .clk40OutA(clk40OutA),
    .clk40OutB(clk40OutB),
    .clk40OutC(clk40OutC),
    .clk320OutA(clk320OutA),
    .clk320OutB(clk320OutB),
    .clk320OutC(clk320OutC),
    .clk640OutA(clk640OutA),
    .clk640OutB(clk640OutB),
    .clk640OutC(clk640OutC),
    .clk1280OutA(clk1280OutA),
    .clk1280OutB(clk1280OutB),
    .clk1280OutC(clk1280OutC),
    .load40A(load40A),
    .load40B(load40B),
    .load40C(load40C),
    .load640A(load640A),
    .load640B(load640B),
    .load640C(load640C),
    .load1280A(load1280A),
    .load1280B(load1280B),
    .load1280C(load1280C)
    );
reg  link_resetA;
reg  link_resetB;
reg  link_resetC;

always @( posedge clk40OutA )
  begin
    link_resetA <= link_reset_refA;
  end

always @( posedge clk40OutB )
  begin
    link_resetB <= link_reset_refB;
  end

always @( posedge clk40OutC )
  begin
    link_resetC <= link_reset_refC;
  end
wire [3:0] enSer320A;
wire [3:0] enSer320B;
wire [3:0] enSer320C;
wire [1:0] enSer640A;
wire [1:0] enSer640B;
wire [1:0] enSer640C;
wire enSer1280A;
wire enSer1280B;
wire enSer1280C;
assign enSer320A =  (rateA==2'b00) ? 4'h1 : ((rateA==2'b01) ? 4'h3 : 4'hF);
assign enSer320B =  (rateB==2'b00) ? 4'h1 : ((rateB==2'b01) ? 4'h3 : 4'hF);
assign enSer320C =  (rateC==2'b00) ? 4'h1 : ((rateC==2'b01) ? 4'h3 : 4'hF);
assign enSer640A =  (rateA==2'b00) ? 2'b00 : ((rateA==2'b01) ? 2'b01 : 2'b11);
assign enSer640B =  (rateB==2'b00) ? 2'b00 : ((rateB==2'b01) ? 2'b01 : 2'b11);
assign enSer640C =  (rateC==2'b00) ? 2'b00 : ((rateC==2'b01) ? 2'b01 : 2'b11);
assign enSer1280A =  rateA[1] ;
assign enSer1280B =  rateB[1] ;
assign enSer1280C =  rateC[1] ;
wire disPRBS8A;
wire disPRBS8B;
wire disPRBS8C;
wire disPRBS16A;
wire disPRBS16B;
wire disPRBS16C;
wire disPRBS32A;
wire disPRBS32B;
wire disPRBS32C;
assign disPRBS8A =  ~link_resetA|testPatternSelA|(rateA!=2'b00);
assign disPRBS8B =  ~link_resetB|testPatternSelB|(rateB!=2'b00);
assign disPRBS8C =  ~link_resetC|testPatternSelC|(rateC!=2'b00);
assign disPRBS16A =  ~link_resetA|testPatternSelA|(rateA!=2'b01);
assign disPRBS16B =  ~link_resetB|testPatternSelB|(rateB!=2'b01);
assign disPRBS16C =  ~link_resetC|testPatternSelC|(rateC!=2'b01);
assign disPRBS32A =  ~link_resetA|testPatternSelA|(rateA[1] !=1'b1);
assign disPRBS32B =  ~link_resetB|testPatternSelB|(rateB[1] !=1'b1);
assign disPRBS32C =  ~link_resetC|testPatternSelC|(rateC[1] !=1'b1);
wire [7:0] PRBSData8A;
wire [7:0] PRBSData8B;
wire [7:0] PRBSData8C;
wire [15:0] PRBSData16A;
wire [15:0] PRBSData16B;
wire [15:0] PRBSData16C;
wire [31:0] PRBSData32A;
wire [31:0] PRBSData32B;
wire [31:0] PRBSData32C;
wire resetPRBSA;
wire resetPRBSB;
wire resetPRBSC;
reg  link_reset1DA;
reg  link_reset1DB;
reg  link_reset1DC;

always @( posedge clk40OutA )
  begin
    link_reset1DA <= link_resetA;
  end

always @( posedge clk40OutB )
  begin
    link_reset1DB <= link_resetB;
  end

always @( posedge clk40OutC )
  begin
    link_reset1DC <= link_resetC;
  end
assign resetPRBSA =  link_resetA&~link_reset1DA;
assign resetPRBSB =  link_resetB&~link_reset1DB;
assign resetPRBSC =  link_resetC&~link_reset1DC;

PRBS7TMR #(.WORDWIDTH(8)) prbs7_8 (
    .clkA(clk40OutA),
    .clkB(clk40OutB),
    .clkC(clk40OutC),
    .resetA(resetPRBSA),
    .resetB(resetPRBSB),
    .resetC(resetPRBSC),
    .disA(disPRBS8A),
    .disB(disPRBS8B),
    .disC(disPRBS8C),
    .seedA(7'H3F),
    .seedB(7'H3F),
    .seedC(7'H3F),
    .prbsA(PRBSData8A),
    .prbsB(PRBSData8B),
    .prbsC(PRBSData8C)
    );

PRBS7TMR #(.WORDWIDTH(16)) prbs7_16 (
    .clkA(clk40OutA),
    .clkB(clk40OutB),
    .clkC(clk40OutC),
    .resetA(resetPRBSA),
    .resetB(resetPRBSB),
    .resetC(resetPRBSC),
    .disA(disPRBS16A),
    .disB(disPRBS16B),
    .disC(disPRBS16C),
    .seedA(7'H3F),
    .seedB(7'H3F),
    .seedC(7'H3F),
    .prbsA(PRBSData16A),
    .prbsB(PRBSData16B),
    .prbsC(PRBSData16C)
    );

PRBS7TMR #(.WORDWIDTH(32)) prbs7_32 (
    .clkA(clk40OutA),
    .clkB(clk40OutB),
    .clkC(clk40OutC),
    .resetA(resetPRBSA),
    .resetB(resetPRBSB),
    .resetC(resetPRBSC),
    .disA(disPRBS32A),
    .disB(disPRBS32B),
    .disC(disPRBS32C),
    .seedA(7'H3F),
    .seedB(7'H3F),
    .seedC(7'H3F),
    .prbsA(PRBSData32A),
    .prbsB(PRBSData32B),
    .prbsC(PRBSData32C)
    );
wire [31:0] PRBSDataCombineA;
wire [31:0] PRBSDataCombineB;
wire [31:0] PRBSDataCombineC;
assign PRBSDataCombineA =  (rateA==2'b00) ? {24'd0,PRBSData8A} : ((rateA==2'b01) ? {16'd0,PRBSData16A} : PRBSData32A);
assign PRBSDataCombineB =  (rateB==2'b00) ? {24'd0,PRBSData8B} : ((rateB==2'b01) ? {16'd0,PRBSData16B} : PRBSData32B);
assign PRBSDataCombineC =  (rateC==2'b00) ? {24'd0,PRBSData8C} : ((rateC==2'b01) ? {16'd0,PRBSData16C} : PRBSData32C);
wire [31:0] testPatternA;
wire [31:0] testPatternB;
wire [31:0] testPatternC;
assign testPatternA =  testPatternSelA ? fixedTestPatternA : PRBSDataCombineA;
assign testPatternB =  testPatternSelB ? fixedTestPatternB : PRBSDataCombineB;
assign testPatternC =  testPatternSelC ? fixedTestPatternC : PRBSDataCombineC;
wire [31:0] sourceA =  link_resetA ? testPatternA : dinRegA;
wire [31:0] sourceB =  link_resetB ? testPatternB : dinRegB;
wire [31:0] sourceC =  link_resetC ? testPatternC : dinRegC;
wire [3:0] s320A;
wire [3:0] s320B;
wire [3:0] s320C;
wire [1:0] s640A;
wire [1:0] s640B;
wire [1:0] s640C;
wire s1280A;
wire s1280B;
wire s1280C;
wire data40A [ 31 : 0 ] ;
wire data40B [ 31 : 0 ] ;
wire data40C [ 31 : 0 ] ;
genvar n;

generate
  for(n =  0;n<8;n =  n+1)
    begin 
      assign data40A[n]  =  (rateA==2'b00) ? sourceA[n]  : (rateA==2'b01 ? sourceA[n*2]  : sourceA[n*4] );
      assign data40B[n]  =  (rateB==2'b00) ? sourceB[n]  : (rateB==2'b01 ? sourceB[n*2]  : sourceB[n*4] );
      assign data40C[n]  =  (rateC==2'b00) ? sourceC[n]  : (rateC==2'b01 ? sourceC[n*2]  : sourceC[n*4] );
      assign data40A[n+8]  =  (rateA==2'b00) ? 1'b0 : (rateA==2'b01 ? sourceA[n*2+1]  : sourceA[n*4+2] );
      assign data40B[n+8]  =  (rateB==2'b00) ? 1'b0 : (rateB==2'b01 ? sourceB[n*2+1]  : sourceB[n*4+2] );
      assign data40C[n+8]  =  (rateC==2'b00) ? 1'b0 : (rateC==2'b01 ? sourceC[n*2+1]  : sourceC[n*4+2] );
      assign data40A[n+16]  =  (rateA==2'b00) ? 1'b0 : (rateA==2'b01 ? 1'b0 : sourceA[n*4+1] );
      assign data40B[n+16]  =  (rateB==2'b00) ? 1'b0 : (rateB==2'b01 ? 1'b0 : sourceB[n*4+1] );
      assign data40C[n+16]  =  (rateC==2'b00) ? 1'b0 : (rateC==2'b01 ? 1'b0 : sourceC[n*4+1] );
      assign data40A[n+24]  =  (rateA==2'b00) ? 1'b0 : (rateA==2'b01 ? 1'b0 : sourceA[n*4+3] );
      assign data40B[n+24]  =  (rateB==2'b00) ? 1'b0 : (rateB==2'b01 ? 1'b0 : sourceB[n*4+3] );
      assign data40C[n+24]  =  (rateC==2'b00) ? 1'b0 : (rateC==2'b01 ? 1'b0 : sourceC[n*4+3] );
    end

endgenerate
genvar i;
wire [7:0] data8InA [ 3 : 0 ] ;
wire [7:0] data8InB [ 3 : 0 ] ;
wire [7:0] data8InC [ 3 : 0 ] ;

generate
  for(i =  0;i<4;i =  i+1)
    begin : loop_s1 
      assign data8InA[i]  =  {data40A[7+8*i] ,data40A[6+8*i] ,data40A[5+8*i] ,data40A[4+8*i] ,data40A[3+8*i] ,data40A[2+8*i] ,data40A[1+8*i] ,data40A[8*i] };
      assign data8InB[i]  =  {data40B[7+8*i] ,data40B[6+8*i] ,data40B[5+8*i] ,data40B[4+8*i] ,data40B[3+8*i] ,data40B[2+8*i] ,data40B[1+8*i] ,data40B[8*i] };
      assign data8InC[i]  =  {data40C[7+8*i] ,data40C[6+8*i] ,data40C[5+8*i] ,data40C[4+8*i] ,data40C[3+8*i] ,data40C[2+8*i] ,data40C[1+8*i] ,data40C[8*i] };

      serializerBlockTMR #(.WORDWIDTH(8)) s320Inst (
          .enableA(enSer320A[i] ),
          .enableB(enSer320B[i] ),
          .enableC(enSer320C[i] ),
          .loadA(load40A),
          .loadB(load40B),
          .loadC(load40C),
          .bitCKA(clk320OutA),
          .bitCKB(clk320OutB),
          .bitCKC(clk320OutC),
          .dinA(data8InA[i] ),
          .dinB(data8InB[i] ),
          .dinC(data8InC[i] ),
          .soutA(s320A[i] ),
          .soutB(s320B[i] ),
          .soutC(s320C[i] )
          );
    end

endgenerate
genvar j;
wire [1:0] data2InA [ 1 : 0 ] ;
wire [1:0] data2InB [ 1 : 0 ] ;
wire [1:0] data2InC [ 1 : 0 ] ;

generate
  for(j =  0;j<2;j =  j+1)
    begin : loop_s2 
      assign data2InA[j]  =  {s320A[2*j+1] ,s320A[2*j] };
      assign data2InB[j]  =  {s320B[2*j+1] ,s320B[2*j] };
      assign data2InC[j]  =  {s320C[2*j+1] ,s320C[2*j] };

      serializerBlockTMR #(.WORDWIDTH(2)) s640Inst (
          .enableA(enSer640A[j] ),
          .enableB(enSer640B[j] ),
          .enableC(enSer640C[j] ),
          .loadA(load640A),
          .loadB(load640B),
          .loadC(load640C),
          .bitCKA(clk640OutA),
          .bitCKB(clk640OutB),
          .bitCKC(clk640OutC),
          .dinA(data2InA[j] ),
          .dinB(data2InB[j] ),
          .dinC(data2InC[j] ),
          .soutA(s640A[j] ),
          .soutB(s640B[j] ),
          .soutC(s640C[j] )
          );
    end

endgenerate

serializerBlockTMR #(.WORDWIDTH(2)) s128Inst (
    .enableA(enSer1280A),
    .enableB(enSer1280B),
    .enableC(enSer1280C),
    .loadA(load1280A),
    .loadB(load1280B),
    .loadC(load1280C),
    .bitCKA(clk1280OutA),
    .bitCKB(clk1280OutB),
    .bitCKC(clk1280OutC),
    .dinA(s640A),
    .dinB(s640B),
    .dinC(s640C),
    .soutA(s1280A),
    .soutB(s1280B),
    .soutC(s1280C)
    );
wire soutMUXA =  disA ? 1'b0 : ((rateA[1] ==1'b1) ? s1280A : (rateA==2'b01 ? s640A[0]  : s320A[0] ));
wire soutMUXB =  disB ? 1'b0 : ((rateB[1] ==1'b1) ? s1280B : (rateB==2'b01 ? s640B[0]  : s320B[0] ));
wire soutMUXC =  disC ? 1'b0 : ((rateC[1] ==1'b1) ? s1280C : (rateC==2'b01 ? s640C[0]  : s320C[0] ));
assign sout =  soutMUX;

majorityVoter soutMUXVoter (
    .inA(soutMUXA),
    .inB(soutMUXB),
    .inC(soutMUXC),
    .out(soutMUX),
    .tmrErr(soutMUXTmrError)
    );
endmodule

