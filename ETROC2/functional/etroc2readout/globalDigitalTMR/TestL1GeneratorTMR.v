/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./globalDigitalTMR/TestL1GeneratorTMR.v                                                *
 *                                                                                                  *
 * user    : dtgong                                                                                 *
 * host    : sphy7asic01.smu.edu                                                                    *
 * date    : 03/04/2022 15:30:02                                                                    *
 *                                                                                                  *
 * workdir : /users/dtgong/workarea/tsmc65/ETLROC/digital/ETROC2Readout/gitlab/etroc2readout        *
 * cmd     : ../../tmrg/tmrg/bin/tmrg -c tmrgGlobal.cnf                                             *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: TestL1Generator.v                                                                      *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2022-03-15 14:02:01.849909                                         *
 *           File Size         : 2796                                                               *
 *           MD5 hash          : 4505c0cf8678f3ea84cfe352db34d5e7                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ns / 100ps

`include  "commonDefinition.v"

module TestL1GeneratorTMR #(
  parameter WORDWIDTH=15,
  parameter FORWARDSTEPS=0
)(
     input  clkTMRA,
     input  clkTMRB,
     input  clkTMRC,
     input  disTMRA,
     input  disTMRB,
     input  disTMRC,
     input  resetTMRA,
     input  resetTMRB,
     input  resetTMRC,
     input  modeTMRA,
     input  modeTMRB,
     input  modeTMRC,
     output  L1ATMRA,
     output  L1ATMRB,
     output  L1ATMRC
);
wor nextCountTmrErrorC;
wire [9:0] nextCountVotedC;
wor nextTriggerCountTmrErrorC;
wire [5:0] nextTriggerCountVotedC;
wor nextCountTmrErrorB;
wire [9:0] nextCountVotedB;
wor nextTriggerCountTmrErrorB;
wire [5:0] nextTriggerCountVotedB;
wor nextTriggerCountTmrErrorA;
wire [5:0] nextTriggerCountVotedA;
wor nextCountTmrErrorA;
wire [9:0] nextCountVotedA;
wire [WORDWIDTH-1:0] prbsA;
wire [WORDWIDTH-1:0] prbsB;
wire [WORDWIDTH-1:0] prbsC;
wire disPRBSA;
wire disPRBSB;
wire disPRBSC;
wire disCountA;
wire disCountB;
wire disCountC;
assign disPRBSA =  disTMRA|~modeTMRA;
assign disPRBSB =  disTMRB|~modeTMRB;
assign disPRBSC =  disTMRC|~modeTMRC;
assign disCountA =  disTMRA|modeTMRA;
assign disCountB =  disTMRB|modeTMRB;
assign disCountC =  disTMRC|modeTMRC;

PRBS31TMR #(.WORDWIDTH(WORDWIDTH), .FORWARDSTEPS(FORWARDSTEPS)) prbs_inst (
          .clkTMRA(clkTMRA),
          .clkTMRB(clkTMRB),
          .clkTMRC(clkTMRC),
          .resetTMRA(resetTMRA),
          .resetTMRB(resetTMRB),
          .resetTMRC(resetTMRC),
          .disTMRA(disPRBSA),
          .disTMRB(disPRBSB),
          .disTMRC(disPRBSC),
          .seedTMRA(31'h2AAAAAAA),
          .seedTMRB(31'h2AAAAAAA),
          .seedTMRC(31'h2AAAAAAA),
          .prbsTMRA(prbsA),
          .prbsTMRB(prbsB),
          .prbsTMRC(prbsC)
          );
reg  startTMRA;
reg  startTMRB;
reg  startTMRC;
reg  [9:0] countTMRA;
reg  [9:0] countTMRB;
reg  [9:0] countTMRC;
wire [9:0] nextCountA =  countTMRA+10'd1;
wire [9:0] nextCountB =  countTMRB+10'd1;
wire [9:0] nextCountC =  countTMRC+10'd1;

always @( posedge clkTMRA )
     begin
          if (!resetTMRA)
               begin
                    countTMRA <= 10'h000;
                    startTMRA <= 1'b0;
               end
          else
               begin
                    if (startTMRA==1'b0)
                         begin
                              countTMRA <= nextCountVotedA;
                              if (countTMRA==10'd512)
                                   begin
                                        startTMRA <= 1'b1;
                                   end
                         end
               end
     end

always @( posedge clkTMRB )
     begin
          if (!resetTMRB)
               begin
                    countTMRB <= 10'h000;
                    startTMRB <= 1'b0;
               end
          else
               begin
                    if (startTMRB==1'b0)
                         begin
                              countTMRB <= nextCountVotedB;
                              if (countTMRB==10'd512)
                                   begin
                                        startTMRB <= 1'b1;
                                   end
                         end
               end
     end

always @( posedge clkTMRC )
     begin
          if (!resetTMRC)
               begin
                    countTMRC <= 10'h000;
                    startTMRC <= 1'b0;
               end
          else
               begin
                    if (startTMRC==1'b0)
                         begin
                              countTMRC <= nextCountVotedC;
                              if (countTMRC==10'd512)
                                   begin
                                        startTMRC <= 1'b1;
                                   end
                         end
               end
     end
reg  [5:0] triggerCountTMRA;
reg  [5:0] triggerCountTMRB;
reg  [5:0] triggerCountTMRC;
wire [5:0] nextTriggerCountA =  triggerCountTMRA+6'd1;
wire [5:0] nextTriggerCountB =  triggerCountTMRB+6'd1;
wire [5:0] nextTriggerCountC =  triggerCountTMRC+6'd1;

always @( posedge clkTMRA )
     if (!resetTMRA)
          begin
               triggerCountTMRA <= 6'h00;
          end
     else
          if (!disCountA)
               begin
                    if (triggerCountTMRA==6'd40)
                         begin
                              triggerCountTMRA <= 6'h00;
                         end
                    else
                         begin
                              triggerCountTMRA <= nextTriggerCountVotedA;
                         end
               end

always @( posedge clkTMRB )
     if (!resetTMRB)
          begin
               triggerCountTMRB <= 6'h00;
          end
     else
          if (!disCountB)
               begin
                    if (triggerCountTMRB==6'd40)
                         begin
                              triggerCountTMRB <= 6'h00;
                         end
                    else
                         begin
                              triggerCountTMRB <= nextTriggerCountVotedB;
                         end
               end

always @( posedge clkTMRC )
     if (!resetTMRC)
          begin
               triggerCountTMRC <= 6'h00;
          end
     else
          if (!disCountC)
               begin
                    if (triggerCountTMRC==6'd40)
                         begin
                              triggerCountTMRC <= 6'h00;
                         end
                    else
                         begin
                              triggerCountTMRC <= nextTriggerCountVotedC;
                         end
               end
assign L1ATMRA =  !startTMRA ? 1'b0 : (modeTMRA ? (prbsA<`L1A_THRESHOLD) : triggerCountTMRA==6'd40);
assign L1ATMRB =  !startTMRB ? 1'b0 : (modeTMRB ? (prbsB<`L1A_THRESHOLD) : triggerCountTMRB==6'd40);
assign L1ATMRC =  !startTMRC ? 1'b0 : (modeTMRC ? (prbsC<`L1A_THRESHOLD) : triggerCountTMRC==6'd40);

majorityVoter #(.WIDTH(10)) nextCountVoterA (
          .inA(nextCountA),
          .inB(nextCountB),
          .inC(nextCountC),
          .out(nextCountVotedA),
          .tmrErr(nextCountTmrErrorA)
          );

majorityVoter #(.WIDTH(6)) nextTriggerCountVoterA (
          .inA(nextTriggerCountA),
          .inB(nextTriggerCountB),
          .inC(nextTriggerCountC),
          .out(nextTriggerCountVotedA),
          .tmrErr(nextTriggerCountTmrErrorA)
          );

majorityVoter #(.WIDTH(6)) nextTriggerCountVoterB (
          .inA(nextTriggerCountA),
          .inB(nextTriggerCountB),
          .inC(nextTriggerCountC),
          .out(nextTriggerCountVotedB),
          .tmrErr(nextTriggerCountTmrErrorB)
          );

majorityVoter #(.WIDTH(10)) nextCountVoterB (
          .inA(nextCountA),
          .inB(nextCountB),
          .inC(nextCountC),
          .out(nextCountVotedB),
          .tmrErr(nextCountTmrErrorB)
          );

majorityVoter #(.WIDTH(6)) nextTriggerCountVoterC (
          .inA(nextTriggerCountA),
          .inB(nextTriggerCountB),
          .inC(nextTriggerCountC),
          .out(nextTriggerCountVotedC),
          .tmrErr(nextTriggerCountTmrErrorC)
          );

majorityVoter #(.WIDTH(10)) nextCountVoterC (
          .inA(nextCountA),
          .inB(nextCountB),
          .inC(nextCountC),
          .out(nextCountVotedC),
          .tmrErr(nextCountTmrErrorC)
          );
endmodule

