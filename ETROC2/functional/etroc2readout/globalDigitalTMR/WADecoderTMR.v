/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./WADecoderTMR.v                                                                       *
 *                                                                                                  *
 * user    : dtgong                                                                                 *
 * host    : sphy7asic01.smu.edu                                                                    *
 * date    : 20/06/2022 13:44:36                                                                    *
 *                                                                                                  *
 * workdir : /users/dtgong/workarea/tsmc65/ETLROC/digital/ETROC2Readout/gitlab/etroc2readout/tmpTMR *
 * cmd     : /users/qsun/workarea/tsmc65nm/ETROC_PLL/digital_work/tmrg/bin/tmrg                     *
 *           ../fastcommand/WADecoder.v ../fastcommand/decoderHamming8to4.v                         *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: ../fastcommand/WADecoder.v                                                             *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2022-06-20 13:41:31.456951                                         *
 *           File Size         : 3936                                                               *
 *           MD5 hash          : 3fec7529beffdcbcb74d633ba62a789d                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ns/1ps
module WADecoderTMR(
  input  rstnA,
  input  rstnB,
  input  rstnC,
  input  clk320_alignedA,
  input  clk320_alignedB,
  input  clk320_alignedC,
  input  fcA,
  input  fcB,
  input  fcC,
  output reg  invalidCmdA,
  output reg  invalidCmdB,
  output reg  invalidCmdC,
  output reg  wordAlignedA,
  output reg  wordAlignedB,
  output reg  wordAlignedC,
  output reg [9:0] fcdA,
  output reg [9:0] fcdB,
  output reg [9:0] fcdC
);
localparam    IDLE=4'HE;
localparam    LinkReset=4'H2;
localparam    BCR=4'H5;
localparam    SyncForTrig=4'H4;
localparam    L1A_CR=4'H6;
localparam    ChargeInj=4'H7;
localparam    L1A=4'H8;
localparam    L1A_BCR=4'H9;
localparam    WS_Start=4'HA;
localparam    WS_Stop=4'HB;
wor cntNextTmrErrorC;
wire [2:0] cntNextVotedC;
wor cntNextTmrErrorB;
wire [2:0] cntNextVotedB;
wor cntNextTmrErrorA;
wire [2:0] cntNextVotedA;
reg  [7:0] fcRegA;
reg  [7:0] fcReg1A;
reg  [7:0] fcRegB;
reg  [7:0] fcReg1B;
reg  [7:0] fcRegC;
reg  [7:0] fcReg1C;
reg  [2:0] cntA;
reg  [2:0] cntB;
reg  [2:0] cntC;

always @( posedge clk320_alignedA )
  begin
    fcRegA[7:0]  <= {fcRegA[6:0] ,fcA};
  end

always @( posedge clk320_alignedB )
  begin
    fcRegB[7:0]  <= {fcRegB[6:0] ,fcB};
  end

always @( posedge clk320_alignedC )
  begin
    fcRegC[7:0]  <= {fcRegC[6:0] ,fcC};
  end
reg  [3:0] confirmCountA;
reg  [3:0] confirmCountB;
reg  [3:0] confirmCountC;

always @( posedge clk320_alignedA )
  begin
    if (~rstnA)
      begin
        fcReg1A <= 8'd0;
      end
    else
      if (cntA==3'b111)
        begin
          fcReg1A <= fcRegA;
        end
  end

always @( posedge clk320_alignedB )
  begin
    if (~rstnB)
      begin
        fcReg1B <= 8'd0;
      end
    else
      if (cntB==3'b111)
        begin
          fcReg1B <= fcRegB;
        end
  end

always @( posedge clk320_alignedC )
  begin
    if (~rstnC)
      begin
        fcReg1C <= 8'd0;
      end
    else
      if (cntC==3'b111)
        begin
          fcReg1C <= fcRegC;
        end
  end
wire wordAlignedNextA =  (confirmCountA==4'd15) ? 1'b1 : wordAlignedA;
wire wordAlignedNextB =  (confirmCountB==4'd15) ? 1'b1 : wordAlignedB;
wire wordAlignedNextC =  (confirmCountC==4'd15) ? 1'b1 : wordAlignedC;
wire wordAlignedVotedA =  wordAlignedNextA;
wire wordAlignedVotedB =  wordAlignedNextB;
wire wordAlignedVotedC =  wordAlignedNextC;

always @( posedge clk320_alignedA )
  begin
    if (~rstnA)
      begin
        wordAlignedA <= 1'b0;
      end
    else
      begin
        wordAlignedA <= wordAlignedVotedA;
      end
  end

always @( posedge clk320_alignedB )
  begin
    if (~rstnB)
      begin
        wordAlignedB <= 1'b0;
      end
    else
      begin
        wordAlignedB <= wordAlignedVotedB;
      end
  end

always @( posedge clk320_alignedC )
  begin
    if (~rstnC)
      begin
        wordAlignedC <= 1'b0;
      end
    else
      begin
        wordAlignedC <= wordAlignedVotedC;
      end
  end
wire [3:0] confirmCountNextA =  (wordAlignedA==1'b0&&cntA==3'd7) ? (fcRegA==8'HF0 ? confirmCountA+1 : 4'd0) : confirmCountA;
wire [3:0] confirmCountNextB =  (wordAlignedB==1'b0&&cntB==3'd7) ? (fcRegB==8'HF0 ? confirmCountB+1 : 4'd0) : confirmCountB;
wire [3:0] confirmCountNextC =  (wordAlignedC==1'b0&&cntC==3'd7) ? (fcRegC==8'HF0 ? confirmCountC+1 : 4'd0) : confirmCountC;
wire [3:0] confirmCountVotedA =  confirmCountNextA;
wire [3:0] confirmCountVotedB =  confirmCountNextB;
wire [3:0] confirmCountVotedC =  confirmCountNextC;

always @( posedge clk320_alignedA )
  begin
    if (~rstnA)
      begin
        confirmCountA <= 4'd0;
      end
    else
      begin
        confirmCountA <= confirmCountVotedA;
      end
  end

always @( posedge clk320_alignedB )
  begin
    if (~rstnB)
      begin
        confirmCountB <= 4'd0;
      end
    else
      begin
        confirmCountB <= confirmCountVotedB;
      end
  end

always @( posedge clk320_alignedC )
  begin
    if (~rstnC)
      begin
        confirmCountC <= 4'd0;
      end
    else
      begin
        confirmCountC <= confirmCountVotedC;
      end
  end
wire [2:0] cntNextA =  (fcRegA==8'HF0&&wordAlignedVotedA==1'b0) ? 3'd0 : cntA+1'b1;
wire [2:0] cntNextB =  (fcRegB==8'HF0&&wordAlignedVotedB==1'b0) ? 3'd0 : cntB+1'b1;
wire [2:0] cntNextC =  (fcRegC==8'HF0&&wordAlignedVotedC==1'b0) ? 3'd0 : cntC+1'b1;

always @( posedge clk320_alignedA )
  begin
    if (~rstnA)
      begin
        cntA <= 3'd0;
      end
    else
      begin
        cntA <= cntNextVotedA;
      end
  end

always @( posedge clk320_alignedB )
  begin
    if (~rstnB)
      begin
        cntB <= 3'd0;
      end
    else
      begin
        cntB <= cntNextVotedB;
      end
  end

always @( posedge clk320_alignedC )
  begin
    if (~rstnC)
      begin
        cntC <= 3'd0;
      end
    else
      begin
        cntC <= cntNextVotedC;
      end
  end
wire [3:0] DDOA;
wire [3:0] DDOB;
wire [3:0] DDOC;
wire E1A;
wire E1B;
wire E1C;
wire E2A;
wire E2B;
wire E2C;

decoderHamming8to4TMR hammingdecoderInst (
    .DDIA(fcReg1A),
    .DDIB(fcReg1B),
    .DDIC(fcReg1C),
    .DDOA(DDOA),
    .DDOB(DDOB),
    .DDOC(DDOC),
    .E1A(E1A),
    .E1B(E1B),
    .E1C(E1C),
    .E2A(E2A),
    .E2B(E2B),
    .E2C(E2C)
    );

always @( * )
  begin
    case (DDOA)
      IDLE : 
        begin
          fcdA <= 10'b00_0000_0001;
          invalidCmdA <= E2A;
        end
      LinkReset : 
        begin
          fcdA <= 10'b00_0000_0010;
          invalidCmdA <= E2A;
        end
      BCR : 
        begin
          fcdA <= 10'b00_0000_0100;
          invalidCmdA <= E2A;
        end
      SyncForTrig : 
        begin
          fcdA <= 10'b00_0000_1000;
          invalidCmdA <= E2A;
        end
      L1A_CR : 
        begin
          fcdA <= 10'b00_0001_0000;
          invalidCmdA <= E2A;
        end
      ChargeInj : 
        begin
          fcdA <= 10'b00_0010_0000;
          invalidCmdA <= E2A;
        end
      L1A : 
        begin
          fcdA <= 10'b00_0100_0000;
          invalidCmdA <= E2A;
        end
      L1A_BCR : 
        begin
          fcdA <= 10'b00_1000_0000;
          invalidCmdA <= E2A;
        end
      WS_Start : 
        begin
          fcdA <= 10'b01_0000_0000;
          invalidCmdA <= E2A;
        end
      WS_Stop : 
        begin
          fcdA <= 10'b10_0000_0000;
          invalidCmdA <= E2A;
        end
      default : 
        begin
          fcdA <= 10'b00_0000_0001;
          invalidCmdA <= E2A;
        end
    endcase
  end

always @( * )
  begin
    case (DDOB)
      IDLE : 
        begin
          fcdB <= 10'b00_0000_0001;
          invalidCmdB <= E2B;
        end
      LinkReset : 
        begin
          fcdB <= 10'b00_0000_0010;
          invalidCmdB <= E2B;
        end
      BCR : 
        begin
          fcdB <= 10'b00_0000_0100;
          invalidCmdB <= E2B;
        end
      SyncForTrig : 
        begin
          fcdB <= 10'b00_0000_1000;
          invalidCmdB <= E2B;
        end
      L1A_CR : 
        begin
          fcdB <= 10'b00_0001_0000;
          invalidCmdB <= E2B;
        end
      ChargeInj : 
        begin
          fcdB <= 10'b00_0010_0000;
          invalidCmdB <= E2B;
        end
      L1A : 
        begin
          fcdB <= 10'b00_0100_0000;
          invalidCmdB <= E2B;
        end
      L1A_BCR : 
        begin
          fcdB <= 10'b00_1000_0000;
          invalidCmdB <= E2B;
        end
      WS_Start : 
        begin
          fcdB <= 10'b01_0000_0000;
          invalidCmdB <= E2B;
        end
      WS_Stop : 
        begin
          fcdB <= 10'b10_0000_0000;
          invalidCmdB <= E2B;
        end
      default : 
        begin
          fcdB <= 10'b00_0000_0001;
          invalidCmdB <= E2B;
        end
    endcase
  end

always @( * )
  begin
    case (DDOC)
      IDLE : 
        begin
          fcdC <= 10'b00_0000_0001;
          invalidCmdC <= E2C;
        end
      LinkReset : 
        begin
          fcdC <= 10'b00_0000_0010;
          invalidCmdC <= E2C;
        end
      BCR : 
        begin
          fcdC <= 10'b00_0000_0100;
          invalidCmdC <= E2C;
        end
      SyncForTrig : 
        begin
          fcdC <= 10'b00_0000_1000;
          invalidCmdC <= E2C;
        end
      L1A_CR : 
        begin
          fcdC <= 10'b00_0001_0000;
          invalidCmdC <= E2C;
        end
      ChargeInj : 
        begin
          fcdC <= 10'b00_0010_0000;
          invalidCmdC <= E2C;
        end
      L1A : 
        begin
          fcdC <= 10'b00_0100_0000;
          invalidCmdC <= E2C;
        end
      L1A_BCR : 
        begin
          fcdC <= 10'b00_1000_0000;
          invalidCmdC <= E2C;
        end
      WS_Start : 
        begin
          fcdC <= 10'b01_0000_0000;
          invalidCmdC <= E2C;
        end
      WS_Stop : 
        begin
          fcdC <= 10'b10_0000_0000;
          invalidCmdC <= E2C;
        end
      default : 
        begin
          fcdC <= 10'b00_0000_0001;
          invalidCmdC <= E2C;
        end
    endcase
  end

majorityVoter #(.WIDTH(3)) cntNextVoterA (
    .inA(cntNextA),
    .inB(cntNextB),
    .inC(cntNextC),
    .out(cntNextVotedA),
    .tmrErr(cntNextTmrErrorA)
    );

majorityVoter #(.WIDTH(3)) cntNextVoterB (
    .inA(cntNextA),
    .inB(cntNextB),
    .inC(cntNextC),
    .out(cntNextVotedB),
    .tmrErr(cntNextTmrErrorB)
    );

majorityVoter #(.WIDTH(3)) cntNextVoterC (
    .inA(cntNextA),
    .inB(cntNextB),
    .inC(cntNextC),
    .out(cntNextVotedC),
    .tmrErr(cntNextTmrErrorC)
    );
endmodule
