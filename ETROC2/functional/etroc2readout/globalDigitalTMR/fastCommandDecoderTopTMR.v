/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./globalDigitalTMR/fastCommandDecoderTopTMR.v                                          *
 *                                                                                                  *
 * user    : dtgong                                                                                 *
 * host    : sphy7asic01.smu.edu                                                                    *
 * date    : 03/04/2022 15:30:05                                                                    *
 *                                                                                                  *
 * workdir : /users/dtgong/workarea/tsmc65/ETLROC/digital/ETROC2Readout/gitlab/etroc2readout        *
 * cmd     : ../../tmrg/tmrg/bin/tmrg -c tmrgGlobal.cnf                                             *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: fastcommand/fastCommandDecoderTop.v                                                    *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2022-03-28 17:21:24.989703                                         *
 *           File Size         : 3980                                                               *
 *           MD5 hash          : b65b62a49e0d3952c1ee89825b42feb2                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ns / 10ps
module fastCommandDecoderTopTMR(
     input  fccAlignA,
     input  fccAlignB,
     input  fccAlignC,
     input  clk1280A,
     input  clk1280B,
     input  clk1280C,
     input  clk40A,
     input  clk40B,
     input  clk40C,
     input  resetA,
     input  resetB,
     input  resetC,
     input  fcA,
     input  fcB,
     input  fcC,
     input  selfAlignEnA,
     input  selfAlignEnB,
     input  selfAlignEnC,
     input  clkDelayEnA,
     input  clkDelayEnB,
     input  clkDelayEnC,
     input  fcDelayEnA,
     input  fcDelayEnB,
     input  fcDelayEnC,
     output [3:0] state_bitAlignA,
     output [3:0] state_bitAlignB,
     output [3:0] state_bitAlignC,
     output  bitErrorA,
     output  bitErrorB,
     output  bitErrorC,
     output [3:0] edA,
     output [3:0] edB,
     output [3:0] edC,
     output  alignedA,
     output  alignedB,
     output  alignedC,
     output  invalidCmdA,
     output  invalidCmdB,
     output  invalidCmdC,
     output [9:0] fcdA,
     output [9:0] fcdB,
     output [9:0] fcdC
);
wor nextCountTmrErrorC;
wire [1:0] nextCountVotedC;
wor nextCountTmrErrorB;
wire [1:0] nextCountVotedB;
wor nextCountTmrErrorA;
wire [1:0] nextCountVotedA;
reg  rstn40A;
reg  rstn40B;
reg  rstn40C;
reg  rstn1280A;
reg  rstn1280B;
reg  rstn1280C;

always @( posedge clk1280A )
     begin
          rstn1280A <= resetA;
     end

always @( posedge clk1280B )
     begin
          rstn1280B <= resetB;
     end

always @( posedge clk1280C )
     begin
          rstn1280C <= resetC;
     end

reg iResetA;
reg iResetB;
reg iResetC;


always @( negedge clk40A )
     begin
          iResetA <= resetA;  
          rstn40A <= iResetA;
     end

always @( negedge clk40B )
     begin
          iResetB <= resetB;  
          rstn40B <= iResetB;
     end

always @( negedge clk40C )
     begin
          iResetC <= resetC;  
          rstn40C <= iResetC;
     end

wire clk320_alignedA;
wire clk320_alignedB;
wire clk320_alignedC;
wire bitAlignedA;
wire bitAlignedB;
wire bitAlignedC;

bitCLKAlignerTMR CLKAligner_Inst (
          .fccAlignA(fccAlignA),
          .fccAlignB(fccAlignB),
          .fccAlignC(fccAlignC),
          .clk1280A(clk1280A),
          .clk1280B(clk1280B),
          .clk1280C(clk1280C),
          .clk40A(clk40A),
          .clk40B(clk40B),
          .clk40C(clk40C),
          .enableA(selfAlignEnA),
          .enableB(selfAlignEnB),
          .enableC(selfAlignEnC),
          .rstn1280A(rstn1280A),
          .rstn1280B(rstn1280B),
          .rstn1280C(rstn1280C),
          .rstn40A(rstn40A),
          .rstn40B(rstn40B),
          .rstn40C(rstn40C),
          .fcA(fcA),
          .fcB(fcB),
          .fcC(fcC),
          .clk320_alignedA(clk320_alignedA),
          .clk320_alignedB(clk320_alignedB),
          .clk320_alignedC(clk320_alignedC),
          .stateA(state_bitAlignA),
          .stateB(state_bitAlignB),
          .stateC(state_bitAlignC),
          .alignedA(bitAlignedA),
          .alignedB(bitAlignedB),
          .alignedC(bitAlignedC),
          .errorA(bitErrorA),
          .errorB(bitErrorB),
          .errorC(bitErrorC),
          .ed0A(edA[0] ),
          .ed0B(edB[0] ),
          .ed0C(edC[0] ),
          .ed1A(edA[1] ),
          .ed1B(edB[1] ),
          .ed1C(edC[1] ),
          .ed2A(edA[2] ),
          .ed2B(edB[2] ),
          .ed2C(edC[2] ),
          .ed3A(edA[3] ),
          .ed3B(edB[3] ),
          .ed3C(edC[3] )
          );
wire clk320A;
wire clk320B;
wire clk320C;
reg  [1:0] cntA;
reg  [1:0] cntB;
reg  [1:0] cntC;
wire [1:0] nextCountA =  cntA+1'b1;
wire [1:0] nextCountB =  cntB+1'b1;
wire [1:0] nextCountC =  cntC+1'b1;

always @( posedge clk1280A )
     begin
          if (!rstn1280A)
               begin
                    cntA <= 2'b00;
               end
          else
               if (!selfAlignEnA)
                    begin
                         if (cntA==2'b11)
                              cntA <= 2'b00;
                         else
                              cntA <= nextCountVotedA;
                    end
     end

always @( posedge clk1280B )
     begin
          if (!rstn1280B)
               begin
                    cntB <= 2'b00;
               end
          else
               if (!selfAlignEnB)
                    begin
                         if (cntB==2'b11)
                              cntB <= 2'b00;
                         else
                              cntB <= nextCountVotedB;
                    end
     end

always @( posedge clk1280C )
     begin
          if (!rstn1280C)
               begin
                    cntC <= 2'b00;
               end
          else
               if (!selfAlignEnC)
                    begin
                         if (cntC==2'b11)
                              cntC <= 2'b00;
                         else
                              cntC <= nextCountVotedC;
                    end
     end
assign clk320A =  cntA[1] ;
assign clk320B =  cntB[1] ;
assign clk320C =  cntC[1] ;
wire clk320In_manualA;
wire clk320In_manualB;
wire clk320In_manualC;
wire fcIn_manualA;
wire fcIn_manualB;
wire fcIn_manualC;
assign clk320In_manualA =  selfAlignEnA ? 1'b0 : clk320A;
assign clk320In_manualB =  selfAlignEnB ? 1'b0 : clk320B;
assign clk320In_manualC =  selfAlignEnC ? 1'b0 : clk320C;
assign fcIn_manualA =  selfAlignEnA ? 1'b0 : fcA;
assign fcIn_manualB =  selfAlignEnB ? 1'b0 : fcB;
assign fcIn_manualC =  selfAlignEnC ? 1'b0 : fcC;
wire fc_adjA;
wire fc_adjB;
wire fc_adjC;
wire clk320_adjA;
wire clk320_adjB;
wire clk320_adjC;

phaseAdjusterTMR phaseAdjuster_inst (
          .fcA(fcIn_manualA),
          .fcB(fcIn_manualB),
          .fcC(fcIn_manualC),
          .clk320A(clk320In_manualA),
          .clk320B(clk320In_manualB),
          .clk320C(clk320In_manualC),
          .fcOutA(fc_adjA),
          .fcOutB(fc_adjB),
          .fcOutC(fc_adjC),
          .clk320OutA(clk320_adjA),
          .clk320OutB(clk320_adjB),
          .clk320OutC(clk320_adjC),
          .clkDelayEnA(clkDelayEnA),
          .clkDelayEnB(clkDelayEnB),
          .clkDelayEnC(clkDelayEnC),
          .fcDelayEnA(fcDelayEnA),
          .fcDelayEnB(fcDelayEnB),
          .fcDelayEnC(fcDelayEnC)
          );
wire clk320_decA;
wire clk320_decB;
wire clk320_decC;
wire fc_decA;
wire fc_decB;
wire fc_decC;
assign fc_decA =  selfAlignEnA ? fcA : fc_adjA;
assign fc_decB =  selfAlignEnB ? fcB : fc_adjB;
assign fc_decC =  selfAlignEnC ? fcC : fc_adjC;
assign clk320_decA =  selfAlignEnA ? clk320_alignedA : clk320_adjA;
assign clk320_decB =  selfAlignEnB ? clk320_alignedB : clk320_adjB;
assign clk320_decC =  selfAlignEnC ? clk320_alignedC : clk320_adjC;
reg  [1:0] aligned_regA;
reg  [1:0] aligned_regB;
reg  [1:0] aligned_regC;
reg  [1:0] fccAlign_regA;
reg  [1:0] fccAlign_regB;
reg  [1:0] fccAlign_regC;

always @( posedge clk40A )
     begin
          aligned_regA <= {aligned_regA[0] ,bitAlignedA};
          fccAlign_regA <= {fccAlign_regA[0] ,fccAlignA};
     end

always @( posedge clk40B )
     begin
          aligned_regB <= {aligned_regB[0] ,bitAlignedB};
          fccAlign_regB <= {fccAlign_regB[0] ,fccAlignB};
     end

always @( posedge clk40C )
     begin
          aligned_regC <= {aligned_regC[0] ,bitAlignedC};
          fccAlign_regC <= {fccAlign_regC[0] ,fccAlignC};
     end
wire rstDecoderA =  rstn40A&~(aligned_regA[0] &~aligned_regA[1] )&~(fccAlign_regA[0] &~fccAlign_regA[1] );
wire rstDecoderB =  rstn40B&~(aligned_regB[0] &~aligned_regB[1] )&~(fccAlign_regB[0] &~fccAlign_regB[1] );
wire rstDecoderC =  rstn40C&~(aligned_regC[0] &~aligned_regC[1] )&~(fccAlign_regC[0] &~fccAlign_regC[1] );
wire wordAlignedA;
wire wordAlignedB;
wire wordAlignedC;
assign alignedA =  wordAlignedA&aligned_regA[1] ;
assign alignedB =  wordAlignedB&aligned_regB[1] ;
assign alignedC =  wordAlignedC&aligned_regC[1] ;

WADecoderTMR WADecoder_inst (
          .rstnA(rstDecoderA),
          .rstnB(rstDecoderB),
          .rstnC(rstDecoderC),
          .clk320_alignedA(clk320_decA),
          .clk320_alignedB(clk320_decB),
          .clk320_alignedC(clk320_decC),
          .fcA(fc_decA),
          .fcB(fc_decB),
          .fcC(fc_decC),
          .invalidCmdA(invalidCmdA),
          .invalidCmdB(invalidCmdB),
          .invalidCmdC(invalidCmdC),
          .wordAlignedA(wordAlignedA),
          .wordAlignedB(wordAlignedB),
          .wordAlignedC(wordAlignedC),
          .fcdA(fcdA),
          .fcdB(fcdB),
          .fcdC(fcdC)
          );

majorityVoter #(.WIDTH(2)) nextCountVoterA (
          .inA(nextCountA),
          .inB(nextCountB),
          .inC(nextCountC),
          .out(nextCountVotedA),
          .tmrErr(nextCountTmrErrorA)
          );

majorityVoter #(.WIDTH(2)) nextCountVoterB (
          .inA(nextCountA),
          .inB(nextCountB),
          .inC(nextCountC),
          .out(nextCountVotedB),
          .tmrErr(nextCountTmrErrorB)
          );

majorityVoter #(.WIDTH(2)) nextCountVoterC (
          .inA(nextCountA),
          .inB(nextCountB),
          .inC(nextCountC),
          .out(nextCountVotedC),
          .tmrErr(nextCountTmrErrorC)
          );
endmodule

