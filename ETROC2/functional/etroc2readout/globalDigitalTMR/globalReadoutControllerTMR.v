/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./globalDigitalTMR/globalReadoutControllerTMR.v                                        *
 *                                                                                                  *
 * user    : dtgong                                                                                 *
 * host    : sphy7asic01.smu.edu                                                                    *
 * date    : 03/04/2022 15:30:07                                                                    *
 *                                                                                                  *
 * workdir : /users/dtgong/workarea/tsmc65/ETLROC/digital/ETROC2Readout/gitlab/etroc2readout        *
 * cmd     : ../../tmrg/tmrg/bin/tmrg -c tmrgGlobal.cnf                                             *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: globalReadoutController.v                                                              *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2022-03-15 14:02:02.209889                                         *
 *           File Size         : 6249                                                               *
 *           MD5 hash          : 26ad9c17c84f461d2f263d592a2d4fbc                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ns / 100ps

module globalReadoutControllerTMR #(
  parameter L1ADDRWIDTH=7,
  parameter BCSTWIDTH=27
)(
     input  clkA,
     input  clkB,
     input  clkC,
     input  resetA,
     input  resetB,
     input  resetC,
     input  L1AA,
     input  L1AB,
     input  L1AC,
     input [45:0] dnDataA,
     input [45:0] dnDataB,
     input [45:0] dnDataC,
     input  dnUnreadHitA,
     input  dnUnreadHitB,
     input  dnUnreadHitC,
     output reg  dnReadA,
     output reg  dnReadB,
     output reg  dnReadC,
     output [BCSTWIDTH-1:0] dnBCSTA,
     output [BCSTWIDTH-1:0] dnBCSTB,
     output [BCSTWIDTH-1:0] dnBCSTC,
     input [11:0] inBCIDA,
     input [11:0] inBCIDB,
     input [11:0] inBCIDC,
     input  BCBE1AA,
     input  BCBE1AB,
     input  BCBE1AC,
     input  BCBE2AA,
     input  BCBE2AB,
     input  BCBE2AC,
     input  streamBufAlmostFullA,
     input  streamBufAlmostFullB,
     input  streamBufAlmostFullC,
     output [L1ADDRWIDTH-1:0] wordCountA,
     output [L1ADDRWIDTH-1:0] wordCountB,
     output [L1ADDRWIDTH-1:0] wordCountC,
     output wire  eventStartA,
     output wire  eventStartB,
     output wire  eventStartC,
     output reg  hitA,
     output reg  hitB,
     output reg  hitC,
     output [28:0] outTDCDataA,
     output [28:0] outTDCDataB,
     output [28:0] outTDCDataC,
     output reg [7:0] outPixelIDA,
     output reg [7:0] outPixelIDB,
     output reg [7:0] outPixelIDC,
     output reg [11:0] outBCIDA,
     output reg [11:0] outBCIDB,
     output reg [11:0] outBCIDC,
     output reg [1:0] outEAA,
     output reg [1:0] outEAB,
     output reg [1:0] outEAC,
     output reg  outL1BufFullA,
     output reg  outL1BufFullB,
     output reg  outL1BufFullC,
     output wire  outL1BufOverflowA,
     output wire  outL1BufOverflowB,
     output wire  outL1BufOverflowC,
     output reg  outL1BufHalfFullA,
     output reg  outL1BufHalfFullB,
     output reg  outL1BufHalfFullC
);
localparam    almostFullLevel=7'd96;
wor streamBufAlmostFullTmrErrorC;
wire streamBufAlmostFullVotedC;
wor sessionStartNextTmrErrorC;
wire sessionStartNextVotedC;
wor L1BufEmptyTmrErrorC;
wire L1BufEmptyVotedC;
wor streamBufAlmostFullTmrErrorB;
wire streamBufAlmostFullVotedB;
wor sessionStartNextTmrErrorB;
wire sessionStartNextVotedB;
wor L1BufEmptyTmrErrorB;
wire L1BufEmptyVotedB;
wor sessionStartNextTmrErrorA;
wire sessionStartNextVotedA;
wor streamBufAlmostFullTmrErrorA;
wire streamBufAlmostFullVotedA;
wor L1BufEmptyTmrErrorA;
wire L1BufEmptyVotedA;
wire dnResetA;
wire dnResetB;
wire dnResetC;
reg  dnLoadA;
reg  dnLoadB;
reg  dnLoadC;
reg  syncL1AA;
reg  syncL1AB;
reg  syncL1AC;
reg  dnL1AA;
reg  dnL1AB;
reg  dnL1AC;
wire L1BufEmptyA;
wire L1BufEmptyB;
wire L1BufEmptyC;
wire L1BufFullA;
wire L1BufFullB;
wire L1BufFullC;
assign dnResetA =  resetA;
assign dnResetB =  resetB;
assign dnResetC =  resetC;

always @( negedge clkA )
     begin
          dnL1AA <= L1AA;
     end

always @( negedge clkB )
     begin
          dnL1AB <= L1AB;
     end

always @( negedge clkC )
     begin
          dnL1AC <= L1AC;
     end

always @( posedge clkA )
     begin
          syncL1AA <= dnL1AA;
     end

always @( posedge clkB )
     begin
          syncL1AB <= dnL1AB;
     end

always @( posedge clkC )
     begin
          syncL1AC <= dnL1AC;
     end
wire [8:0] CBwrAddrA;
wire [8:0] CBwrAddrB;
wire [8:0] CBwrAddrC;

CircularBufferAddrTMR CBAddrInst (
          .clkA(clkA),
          .clkB(clkB),
          .clkC(clkC),
          .resetA(dnResetA),
          .resetB(dnResetB),
          .resetC(dnResetC),
          .wrAddrA(CBwrAddrA),
          .wrAddrB(CBwrAddrB),
          .wrAddrC(CBwrAddrC)
          );
wire [L1ADDRWIDTH-1:0] L1rdAddrA;
wire [L1ADDRWIDTH-1:0] L1rdAddrB;
wire [L1ADDRWIDTH-1:0] L1rdAddrC;
wire [L1ADDRWIDTH-1:0] L1wrAddrA;
wire [L1ADDRWIDTH-1:0] L1wrAddrB;
wire [L1ADDRWIDTH-1:0] L1wrAddrC;
wire L1HalfFullA;
wire L1HalfFullB;
wire L1HalfFullC;
wire firstEventA;
wire firstEventB;
wire firstEventC;
wire L1BufOverflowA;
wire L1BufOverflowB;
wire L1BufOverflowC;
assign L1HalfFullA =  wordCountA>=7'd64;
assign L1HalfFullB =  wordCountB>=7'd64;
assign L1HalfFullC =  wordCountC>=7'd64;
assign L1BufOverflowA =  wordCountA>=almostFullLevel;
assign L1BufOverflowB =  wordCountB>=almostFullLevel;
assign L1BufOverflowC =  wordCountC>=almostFullLevel;

L1BufferAddrTMR #(.ADDRWIDTH(L1ADDRWIDTH)) L1BAddrInst (
          .clkA(clkA),
          .clkB(clkB),
          .clkC(clkC),
          .resetA(dnResetA),
          .resetB(dnResetB),
          .resetC(dnResetC),
          .wrEnA(syncL1AA),
          .wrEnB(syncL1AB),
          .wrEnC(syncL1AC),
          .rdEnA(dnLoadA),
          .rdEnB(dnLoadB),
          .rdEnC(dnLoadC),
          .wordCountA(wordCountA),
          .wordCountB(wordCountB),
          .wordCountC(wordCountC),
          .wrAddrA(L1wrAddrA),
          .wrAddrB(L1wrAddrB),
          .wrAddrC(L1wrAddrC),
          .rdAddrA(L1rdAddrA),
          .rdAddrB(L1rdAddrB),
          .rdAddrC(L1rdAddrC),
          .emptyA(L1BufEmptyA),
          .emptyB(L1BufEmptyB),
          .emptyC(L1BufEmptyC),
          .firstEventA(firstEventA),
          .firstEventB(firstEventB),
          .firstEventC(firstEventC),
          .fullA(L1BufFullA),
          .fullB(L1BufFullB),
          .fullC(L1BufFullC)
          );
wire [7:0] dnPixelIDA;
wire [7:0] dnPixelIDB;
wire [7:0] dnPixelIDC;
wire [35:0] dnTDCDataA;
wire [35:0] dnTDCDataB;
wire [35:0] dnTDCDataC;
wire [1:0] dnEAA;
wire [1:0] dnEAB;
wire [1:0] dnEAC;
wire preLoadA;
wire preLoadB;
wire preLoadC;
assign dnBCSTA =  {preLoadA,CBwrAddrA,L1wrAddrA,L1rdAddrA,dnLoadA,dnL1AA,dnResetA};
assign dnBCSTB =  {preLoadB,CBwrAddrB,L1wrAddrB,L1rdAddrB,dnLoadB,dnL1AB,dnResetB};
assign dnBCSTC =  {preLoadC,CBwrAddrC,L1wrAddrC,L1rdAddrC,dnLoadC,dnL1AC,dnResetC};
assign dnPixelIDA =  dnDataA[7:0] ;
assign dnPixelIDB =  dnDataB[7:0] ;
assign dnPixelIDC =  dnDataC[7:0] ;
assign dnTDCDataA =  dnDataA[45:10] ;
assign dnTDCDataB =  dnDataB[45:10] ;
assign dnTDCDataC =  dnDataC[45:10] ;
assign dnEAA =  dnDataA[9:8] ;
assign dnEAB =  dnDataB[9:8] ;
assign dnEAC =  dnDataC[9:8] ;
reg  L1BufOverflowRegA;
reg  L1BufOverflowRegB;
reg  L1BufOverflowRegC;
reg  [35:0] encTDCDataA;
reg  [35:0] encTDCDataB;
reg  [35:0] encTDCDataC;
wire [1:0] overallEAA;
wire [1:0] overallEAB;
wire [1:0] overallEAC;
reg  BCBE1ARegA;
reg  BCBE1ARegB;
reg  BCBE1ARegC;
reg  BCBE2ARegA;
reg  BCBE2ARegB;
reg  BCBE2ARegC;

always @( negedge clkA )
     begin
          if (!streamBufAlmostFullVotedA)
               begin
                    hitA <= L1BufOverflowRegA ? 1'b0 : dnUnreadHitA;
                    outBCIDA <= inBCIDA;
                    encTDCDataA <= dnTDCDataA;
                    outPixelIDA <= dnPixelIDA;
                    outL1BufFullA <= L1BufFullA;
                    outL1BufHalfFullA <= L1HalfFullA;
                    outEAA <= overallEAA;
                    BCBE1ARegA <= BCBE1AA;
                    BCBE2ARegA <= BCBE2AA;
               end
     end

always @( negedge clkB )
     begin
          if (!streamBufAlmostFullVotedB)
               begin
                    hitB <= L1BufOverflowRegB ? 1'b0 : dnUnreadHitB;
                    outBCIDB <= inBCIDB;
                    encTDCDataB <= dnTDCDataB;
                    outPixelIDB <= dnPixelIDB;
                    outL1BufFullB <= L1BufFullB;
                    outL1BufHalfFullB <= L1HalfFullB;
                    outEAB <= overallEAB;
                    BCBE1ARegB <= BCBE1AB;
                    BCBE2ARegB <= BCBE2AB;
               end
     end

always @( negedge clkC )
     begin
          if (!streamBufAlmostFullVotedC)
               begin
                    hitC <= L1BufOverflowRegC ? 1'b0 : dnUnreadHitC;
                    outBCIDC <= inBCIDC;
                    encTDCDataC <= dnTDCDataC;
                    outPixelIDC <= dnPixelIDC;
                    outL1BufFullC <= L1BufFullC;
                    outL1BufHalfFullC <= L1HalfFullC;
                    outEAC <= overallEAC;
                    BCBE1ARegC <= BCBE1AC;
                    BCBE2ARegC <= BCBE2AC;
               end
     end
wire dataE1AA;
wire dataE1AB;
wire dataE1AC;
wire dataE2AA;
wire dataE2AB;
wire dataE2AC;

cb_data_mem_decoderTMR decoder0 (
          .DDIA(encTDCDataA),
          .DDIB(encTDCDataB),
          .DDIC(encTDCDataC),
          .DDOA(outTDCDataA),
          .DDOB(outTDCDataB),
          .DDOC(outTDCDataC),
          .E1A(dataE1AA),
          .E1B(dataE1AB),
          .E1C(dataE1AC),
          .E2A(dataE2AA),
          .E2B(dataE2AB),
          .E2C(dataE2AC)
          );
assign overallEAA[0]  =  dataE1AA|dnEAA[0] |BCBE1ARegA;
assign overallEAB[0]  =  dataE1AB|dnEAB[0] |BCBE1ARegB;
assign overallEAC[0]  =  dataE1AC|dnEAC[0] |BCBE1ARegC;
assign overallEAA[1]  =  dataE2AA|dnEAA[1] |BCBE2ARegA;
assign overallEAB[1]  =  dataE2AB|dnEAB[1] |BCBE2ARegB;
assign overallEAC[1]  =  dataE2AC|dnEAC[1] |BCBE2ARegC;
assign eventStartA =  dnLoadA;
assign eventStartB =  dnLoadB;
assign eventStartC =  dnLoadC;
assign outL1BufOverflowA =  L1BufOverflowRegA;
assign outL1BufOverflowB =  L1BufOverflowRegB;
assign outL1BufOverflowC =  L1BufOverflowRegC;
reg  sessionStartA;
reg  sessionStartB;
reg  sessionStartC;
reg  load1DA;
reg  load1DB;
reg  load1DC;
wire sessionStartNextA =  L1BufOverflowRegA ? 1'b0 : dnUnreadHitA;
wire sessionStartNextB =  L1BufOverflowRegB ? 1'b0 : dnUnreadHitB;
wire sessionStartNextC =  L1BufOverflowRegC ? 1'b0 : dnUnreadHitC;

always @( negedge clkA )
     begin
          if (!dnResetA)
               begin
                    dnLoadA <= 1'b0;
                    dnReadA <= 1'b0;
                    sessionStartA <= 1'b0;
                    L1BufOverflowRegA <= 2'b0;
               end
          else
               begin
                    if (!sessionStartA)
                         begin
                              if (~L1BufEmptyVotedA&~streamBufAlmostFullVotedA)
                                   begin
                                        sessionStartA <= 1'b1;
                                        dnLoadA <= 1'b1;
                                        L1BufOverflowRegA <= L1BufOverflowA;
                                   end
                         end
                    else
                         begin
                              dnLoadA <= 1'b0;
                              dnReadA <= L1BufOverflowRegA|streamBufAlmostFullA ? 1'b0 : dnUnreadHitA;
                              if (!streamBufAlmostFullVotedA)
                                   begin
                                        sessionStartA <= sessionStartNextVotedA;
                                   end
                         end
               end
          load1DA <= dnLoadA;
     end

always @( negedge clkB )
     begin
          if (!dnResetB)
               begin
                    dnLoadB <= 1'b0;
                    dnReadB <= 1'b0;
                    sessionStartB <= 1'b0;
                    L1BufOverflowRegB <= 2'b0;
               end
          else
               begin
                    if (!sessionStartB)
                         begin
                              if (~L1BufEmptyVotedB&~streamBufAlmostFullVotedB)
                                   begin
                                        sessionStartB <= 1'b1;
                                        dnLoadB <= 1'b1;
                                        L1BufOverflowRegB <= L1BufOverflowB;
                                   end
                         end
                    else
                         begin
                              dnLoadB <= 1'b0;
                              dnReadB <= L1BufOverflowRegB|streamBufAlmostFullB ? 1'b0 : dnUnreadHitB;
                              if (!streamBufAlmostFullVotedB)
                                   begin
                                        sessionStartB <= sessionStartNextVotedB;
                                   end
                         end
               end
          load1DB <= dnLoadB;
     end

always @( negedge clkC )
     begin
          if (!dnResetC)
               begin
                    dnLoadC <= 1'b0;
                    dnReadC <= 1'b0;
                    sessionStartC <= 1'b0;
                    L1BufOverflowRegC <= 2'b0;
               end
          else
               begin
                    if (!sessionStartC)
                         begin
                              if (~L1BufEmptyVotedC&~streamBufAlmostFullVotedC)
                                   begin
                                        sessionStartC <= 1'b1;
                                        dnLoadC <= 1'b1;
                                        L1BufOverflowRegC <= L1BufOverflowC;
                                   end
                         end
                    else
                         begin
                              dnLoadC <= 1'b0;
                              dnReadC <= L1BufOverflowRegC|streamBufAlmostFullC ? 1'b0 : dnUnreadHitC;
                              if (!streamBufAlmostFullVotedC)
                                   begin
                                        sessionStartC <= sessionStartNextVotedC;
                                   end
                         end
               end
          load1DC <= dnLoadC;
     end
assign preLoadA =  (load1DA&~L1BufEmptyA)|firstEventA;
assign preLoadB =  (load1DB&~L1BufEmptyB)|firstEventB;
assign preLoadC =  (load1DC&~L1BufEmptyC)|firstEventC;

majorityVoter L1BufEmptyVoterA (
          .inA(L1BufEmptyA),
          .inB(L1BufEmptyB),
          .inC(L1BufEmptyC),
          .out(L1BufEmptyVotedA),
          .tmrErr(L1BufEmptyTmrErrorA)
          );

majorityVoter streamBufAlmostFullVoterA (
          .inA(streamBufAlmostFullA),
          .inB(streamBufAlmostFullB),
          .inC(streamBufAlmostFullC),
          .out(streamBufAlmostFullVotedA),
          .tmrErr(streamBufAlmostFullTmrErrorA)
          );

majorityVoter sessionStartNextVoterA (
          .inA(sessionStartNextA),
          .inB(sessionStartNextB),
          .inC(sessionStartNextC),
          .out(sessionStartNextVotedA),
          .tmrErr(sessionStartNextTmrErrorA)
          );

majorityVoter L1BufEmptyVoterB (
          .inA(L1BufEmptyA),
          .inB(L1BufEmptyB),
          .inC(L1BufEmptyC),
          .out(L1BufEmptyVotedB),
          .tmrErr(L1BufEmptyTmrErrorB)
          );

majorityVoter sessionStartNextVoterB (
          .inA(sessionStartNextA),
          .inB(sessionStartNextB),
          .inC(sessionStartNextC),
          .out(sessionStartNextVotedB),
          .tmrErr(sessionStartNextTmrErrorB)
          );

majorityVoter streamBufAlmostFullVoterB (
          .inA(streamBufAlmostFullA),
          .inB(streamBufAlmostFullB),
          .inC(streamBufAlmostFullC),
          .out(streamBufAlmostFullVotedB),
          .tmrErr(streamBufAlmostFullTmrErrorB)
          );

majorityVoter L1BufEmptyVoterC (
          .inA(L1BufEmptyA),
          .inB(L1BufEmptyB),
          .inC(L1BufEmptyC),
          .out(L1BufEmptyVotedC),
          .tmrErr(L1BufEmptyTmrErrorC)
          );

majorityVoter sessionStartNextVoterC (
          .inA(sessionStartNextA),
          .inB(sessionStartNextB),
          .inC(sessionStartNextC),
          .out(sessionStartNextVotedC),
          .tmrErr(sessionStartNextTmrErrorC)
          );

majorityVoter streamBufAlmostFullVoterC (
          .inA(streamBufAlmostFullA),
          .inB(streamBufAlmostFullB),
          .inC(streamBufAlmostFullC),
          .out(streamBufAlmostFullVotedC),
          .tmrErr(streamBufAlmostFullTmrErrorC)
          );
endmodule

