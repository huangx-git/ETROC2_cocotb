/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./globalDigitalTMR/ljCDRlockFilterDetectorTMR.v                                        *
 *                                                                                                  *
 * user    : dtgong                                                                                 *
 * host    : sphy7asic01.smu.edu                                                                    *
 * date    : 03/04/2022 15:30:08                                                                    *
 *                                                                                                  *
 * workdir : /users/dtgong/workarea/tsmc65/ETLROC/digital/ETROC2Readout/gitlab/etroc2readout        *
 * cmd     : ../../tmrg/tmrg/bin/tmrg -c tmrgGlobal.cnf                                             *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: lockDetector/ljCDRlockFilterDetector.v                                                 *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2022-03-15 14:02:02.267898                                         *
 *           File Size         : 12439                                                              *
 *           MD5 hash          : 77b8d62f3d0c323791a07039c3bded96                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ps/1ps
module ljCDRlockFilterDetectorTMR(
     input wire  smClockA,
     input wire  smClockB,
     input wire  smClockC,
     input wire  resetA,
     input wire  resetB,
     input wire  resetC,
     input wire  selectFD_PFDA,
     input wire  selectFD_PFDB,
     input wire  selectFD_PFDC,
     input wire  PFDInstLockA,
     input wire  PFDInstLockB,
     input wire  PFDInstLockC,
     input wire  FDInstLockA,
     input wire  FDInstLockB,
     input wire  FDInstLockC,
     input wire [3:0] lfLockThrCounterA,
     input wire [3:0] lfLockThrCounterB,
     input wire [3:0] lfLockThrCounterC,
     input wire [3:0] lfReLockThrCounterA,
     input wire [3:0] lfReLockThrCounterB,
     input wire [3:0] lfReLockThrCounterC,
     input wire [3:0] lfUnLockThrCounterA,
     input wire [3:0] lfUnLockThrCounterB,
     input wire [3:0] lfUnLockThrCounterC,
     output wire [1:0] stateA,
     output wire [1:0] stateB,
     output wire [1:0] stateC,
     output reg  instantLockA,
     output reg  instantLockB,
     output reg  instantLockC,
     output wire  lockedA,
     output wire  lockedB,
     output wire  lockedC,
     output wire [7:0] lossOfLockCountA,
     output wire [7:0] lossOfLockCountB,
     output wire [7:0] lossOfLockCountC
);
wire instantLock_sync0A;
wire instantLock_sync0B;
wire instantLock_sync0C;
assign #10 instantLock_sync0A =  selectFD_PFDA ? PFDInstLockA : FDInstLockA;
assign #10 instantLock_sync0B =  selectFD_PFDB ? PFDInstLockB : FDInstLockB;
assign #10 instantLock_sync0C =  selectFD_PFDC ? PFDInstLockC : FDInstLockC;
reg  instantLock_sync1A;
reg  instantLock_sync2A;
reg  instantLock_sync1B;
reg  instantLock_sync2B;
reg  instantLock_sync1C;
reg  instantLock_sync2C;

always @( posedge smClockA )
     begin
          instantLock_sync1A <= #10 instantLock_sync0A;
          instantLock_sync2A <= #10 instantLock_sync1A;
          instantLockA <= #10 instantLock_sync2A;
     end

always @( posedge smClockB )
     begin
          instantLock_sync1B <= #10 instantLock_sync0B;
          instantLock_sync2B <= #10 instantLock_sync1B;
          instantLockB <= #10 instantLock_sync2B;
     end

always @( posedge smClockC )
     begin
          instantLock_sync1C <= #10 instantLock_sync0C;
          instantLock_sync2C <= #10 instantLock_sync1C;
          instantLockC <= #10 instantLock_sync2C;
     end

ljCDRLockFilterTMR ljCDRLockFilter_inst (
          .clockA(smClockA),
          .clockB(smClockB),
          .clockC(smClockC),
          .resetA(resetA),
          .resetB(resetB),
          .resetC(resetC),
          .instantLockA(instantLockA),
          .instantLockB(instantLockB),
          .instantLockC(instantLockC),
          .lfLockThrCounterA(lfLockThrCounterA),
          .lfLockThrCounterB(lfLockThrCounterB),
          .lfLockThrCounterC(lfLockThrCounterC),
          .lfReLockThrCounterA(lfReLockThrCounterA),
          .lfReLockThrCounterB(lfReLockThrCounterB),
          .lfReLockThrCounterC(lfReLockThrCounterC),
          .lfUnLockThrCounterA(lfUnLockThrCounterA),
          .lfUnLockThrCounterB(lfUnLockThrCounterB),
          .lfUnLockThrCounterC(lfUnLockThrCounterC),
          .stateA(stateA),
          .stateB(stateB),
          .stateC(stateC),
          .lockedA(lockedA),
          .lockedB(lockedB),
          .lockedC(lockedC),
          .lossOfLockCountA(lossOfLockCountA),
          .lossOfLockCountB(lossOfLockCountB),
          .lossOfLockCountC(lossOfLockCountC)
          );
endmodule

module ljCDRLockFilterTMR(
     input wire  clockA,
     input wire  clockB,
     input wire  clockC,
     input wire  resetA,
     input wire  resetB,
     input wire  resetC,
     input wire  instantLockA,
     input wire  instantLockB,
     input wire  instantLockC,
     input wire [3:0] lfLockThrCounterA,
     input wire [3:0] lfLockThrCounterB,
     input wire [3:0] lfLockThrCounterC,
     input wire [3:0] lfReLockThrCounterA,
     input wire [3:0] lfReLockThrCounterB,
     input wire [3:0] lfReLockThrCounterC,
     input wire [3:0] lfUnLockThrCounterA,
     input wire [3:0] lfUnLockThrCounterB,
     input wire [3:0] lfUnLockThrCounterC,
     output reg [1:0] stateA,
     output reg [1:0] stateB,
     output reg [1:0] stateC,
     output reg  lockedA,
     output reg  lockedB,
     output reg  lockedC,
     output reg [7:0] lossOfLockCountA,
     output reg [7:0] lossOfLockCountB,
     output reg [7:0] lossOfLockCountC
);
localparam    lfUnlfLockedState=2'b00;
localparam    lfConfirmLockState=2'b01;
localparam    lfLockedState=2'b10;
localparam    lfConfirmUnlockState=2'b11;
wor nextLossOfLockCountTmrErrorC;
wire [7:0] nextLossOfLockCountVotedC;
wor stateTmrErrorC;
wire [1:0] stateVotedC;
wor resetTmrErrorC;
wire resetVotedC;
wor unLockedCountTmrErrorC;
wire [15:0] unLockedCountVotedC;
wor nextLockedCountTmrErrorC;
wire [15:0] nextLockedCountVotedC;
wor nextUnLockedCountTmrErrorC;
wire [15:0] nextUnLockedCountVotedC;
wor lfReLockThrCounterRegTmrErrorC;
wire [15:0] lfReLockThrCounterRegVotedC;
wor nextLockedTmrErrorC;
wire nextLockedVotedC;
wor lockedCountTmrErrorC;
wire [15:0] lockedCountVotedC;
wor instantLockTmrErrorC;
wire instantLockVotedC;
wor lfLockThrCounterRegTmrErrorC;
wire [15:0] lfLockThrCounterRegVotedC;
wor lfUnLockThrCounterRegTmrErrorC;
wire [15:0] lfUnLockThrCounterRegVotedC;
wor nextStateTmrErrorC;
wire [1:0] nextStateVotedC;
wor lossOfLockCountTmrErrorC;
wire [7:0] lossOfLockCountVotedC;
wor lfUnLockThrCounterRegTmrErrorB;
wire [15:0] lfUnLockThrCounterRegVotedB;
wor stateTmrErrorB;
wire [1:0] stateVotedB;
wor nextLockedCountTmrErrorB;
wire [15:0] nextLockedCountVotedB;
wor unLockedCountTmrErrorB;
wire [15:0] unLockedCountVotedB;
wor resetTmrErrorB;
wire resetVotedB;
wor nextLossOfLockCountTmrErrorB;
wire [7:0] nextLossOfLockCountVotedB;
wor nextUnLockedCountTmrErrorB;
wire [15:0] nextUnLockedCountVotedB;
wor lfReLockThrCounterRegTmrErrorB;
wire [15:0] lfReLockThrCounterRegVotedB;
wor nextLockedTmrErrorB;
wire nextLockedVotedB;
wor instantLockTmrErrorB;
wire instantLockVotedB;
wor nextStateTmrErrorB;
wire [1:0] nextStateVotedB;
wor lockedCountTmrErrorB;
wire [15:0] lockedCountVotedB;
wor lfLockThrCounterRegTmrErrorB;
wire [15:0] lfLockThrCounterRegVotedB;
wor lossOfLockCountTmrErrorB;
wire [7:0] lossOfLockCountVotedB;
wor lockedCountTmrErrorA;
wire [15:0] lockedCountVotedA;
wor stateTmrErrorA;
wire [1:0] stateVotedA;
wor nextLossOfLockCountTmrErrorA;
wire [7:0] nextLossOfLockCountVotedA;
wor resetTmrErrorA;
wire resetVotedA;
wor unLockedCountTmrErrorA;
wire [15:0] unLockedCountVotedA;
wor nextUnLockedCountTmrErrorA;
wire [15:0] nextUnLockedCountVotedA;
wor nextLockedTmrErrorA;
wire nextLockedVotedA;
wor nextStateTmrErrorA;
wire [1:0] nextStateVotedA;
wor lfReLockThrCounterRegTmrErrorA;
wire [15:0] lfReLockThrCounterRegVotedA;
wor nextLockedCountTmrErrorA;
wire [15:0] nextLockedCountVotedA;
wor instantLockTmrErrorA;
wire instantLockVotedA;
wor lfLockThrCounterRegTmrErrorA;
wire [15:0] lfLockThrCounterRegVotedA;
wor lfUnLockThrCounterRegTmrErrorA;
wire [15:0] lfUnLockThrCounterRegVotedA;
wor lossOfLockCountTmrErrorA;
wire [7:0] lossOfLockCountVotedA;
wire [15:0] lfLockThrCounterRegA;
wire [15:0] lfLockThrCounterRegB;
wire [15:0] lfLockThrCounterRegC;
wire [15:0] lfReLockThrCounterRegA;
wire [15:0] lfReLockThrCounterRegB;
wire [15:0] lfReLockThrCounterRegC;
wire [15:0] lfUnLockThrCounterRegA;
wire [15:0] lfUnLockThrCounterRegB;
wire [15:0] lfUnLockThrCounterRegC;
assign lfLockThrCounterRegA =  16'h0001<<lfLockThrCounterA;
assign lfLockThrCounterRegB =  16'h0001<<lfLockThrCounterB;
assign lfLockThrCounterRegC =  16'h0001<<lfLockThrCounterC;
assign lfReLockThrCounterRegA =  16'h0001<<lfReLockThrCounterA;
assign lfReLockThrCounterRegB =  16'h0001<<lfReLockThrCounterB;
assign lfReLockThrCounterRegC =  16'h0001<<lfReLockThrCounterC;
assign lfUnLockThrCounterRegA =  16'h0001<<lfUnLockThrCounterA;
assign lfUnLockThrCounterRegB =  16'h0001<<lfUnLockThrCounterB;
assign lfUnLockThrCounterRegC =  16'h0001<<lfUnLockThrCounterC;
reg  [15:0] unLockedCountA;
reg  [15:0] unLockedCountB;
reg  [15:0] unLockedCountC;
reg  [15:0] lockedCountA;
reg  [15:0] lockedCountB;
reg  [15:0] lockedCountC;
reg  [1:0] nextStateA;
reg  [1:0] nextStateB;
reg  [1:0] nextStateC;
reg  nextLockedA;
reg  nextLockedB;
reg  nextLockedC;
reg  [15:0] nextUnLockedCountA;
reg  [15:0] nextUnLockedCountB;
reg  [15:0] nextUnLockedCountC;
reg  [15:0] nextLockedCountA;
reg  [15:0] nextLockedCountB;
reg  [15:0] nextLockedCountC;
reg  [7:0] nextLossOfLockCountA;
reg  [7:0] nextLossOfLockCountB;
reg  [7:0] nextLossOfLockCountC;

always @*
     begin
          case (stateVotedA)
               lfUnlfLockedState : 
                    begin
                         if (instantLockVotedA)
                              begin
                                   nextStateA <= #10 lfConfirmLockState;
                                   nextLockedA <= #10 1'b0;
                                   nextUnLockedCountA <= #10 16'h0000;
                                   nextLockedCountA <= #10 lockedCountVotedA+16'h0001;
                                   nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                              end
                         else
                              begin
                                   nextStateA <= #10 lfUnlfLockedState;
                                   nextLockedA <= #10 1'b0;
                                   nextUnLockedCountA <= #10 16'h0000;
                                   nextLockedCountA <= #10 16'h0000;
                                   nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                              end
                    end
               lfConfirmLockState : 
                    begin
                         if (lockedCountVotedA==lfLockThrCounterRegVotedA)
                              begin
                                   nextStateA <= #10 lfLockedState;
                                   nextLockedA <= #10 1'b1;
                                   nextUnLockedCountA <= #10 16'h0000;
                                   nextLockedCountA <= #10 16'h0000;
                                   nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                              end
                         else
                              begin
                                   if (instantLockVotedA)
                                        begin
                                             nextStateA <= #10 lfConfirmLockState;
                                             nextLockedA <= #10 1'b0;
                                             nextUnLockedCountA <= #10 16'h0000;
                                             nextLockedCountA <= #10 lockedCountVotedA+16'h0001;
                                             nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                                        end
                                   else
                                        begin
                                             nextStateA <= #10 lfUnlfLockedState;
                                             nextLockedA <= #10 1'b0;
                                             nextUnLockedCountA <= #10 16'h0000;
                                             nextLockedCountA <= #10 16'h0000;
                                             nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                                        end
                              end
                    end
               lfLockedState : 
                    begin
                         if (instantLockVotedA==1'b1)
                              begin
                                   nextStateA <= #10 lfLockedState;
                                   nextLockedA <= #10 1'b1;
                                   nextUnLockedCountA <= #10 16'h0000;
                                   nextLockedCountA <= #10 16'h0000;
                                   nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                              end
                         else
                              begin
                                   nextStateA <= #10 lfConfirmUnlockState;
                                   nextLockedA <= #10 1'b1;
                                   nextUnLockedCountA <= #10 16'h0001;
                                   nextLockedCountA <= #10 16'h0000;
                                   nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                              end
                    end
               lfConfirmUnlockState : 
                    begin
                         if (lockedCountVotedA==lfReLockThrCounterRegVotedA)
                              begin
                                   nextStateA <= #10 lfLockedState;
                                   nextLockedA <= #10 1'b1;
                                   nextUnLockedCountA <= #10 16'h0000;
                                   nextLockedCountA <= #10 16'h0000;
                                   nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                              end
                         else
                              begin
                                   if (unLockedCountVotedA==lfUnLockThrCounterRegVotedA)
                                        begin
                                             nextStateA <= #10 lfUnlfLockedState;
                                             nextLockedA <= #10 1'b0;
                                             nextUnLockedCountA <= #10 16'h0000;
                                             nextLockedCountA <= #10 16'h0000;
                                             nextLossOfLockCountA <= #10 lossOfLockCountVotedA+8'h01;
                                        end
                                   else
                                        begin
                                             if (instantLockVotedA==1'b1)
                                                  begin
                                                       nextStateA <= #10 lfConfirmUnlockState;
                                                       nextLockedA <= #10 1'b1;
                                                       nextUnLockedCountA <= #10 unLockedCountVotedA;
                                                       nextLockedCountA <= #10 lockedCountVotedA+16'h0001;
                                                       nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                                                  end
                                             else
                                                  begin
                                                       nextStateA <= #10 lfConfirmUnlockState;
                                                       nextLockedA <= #10 1'b1;
                                                       nextUnLockedCountA <= #10 unLockedCountVotedA+16'h0001;
                                                       nextLockedCountA <= #10 16'h0000;
                                                       nextLossOfLockCountA <= #10 lossOfLockCountVotedA;
                                                  end
                                        end
                              end
                    end
          endcase
     end

always @*
     begin
          case (stateVotedB)
               lfUnlfLockedState : 
                    begin
                         if (instantLockVotedB)
                              begin
                                   nextStateB <= #10 lfConfirmLockState;
                                   nextLockedB <= #10 1'b0;
                                   nextUnLockedCountB <= #10 16'h0000;
                                   nextLockedCountB <= #10 lockedCountVotedB+16'h0001;
                                   nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                              end
                         else
                              begin
                                   nextStateB <= #10 lfUnlfLockedState;
                                   nextLockedB <= #10 1'b0;
                                   nextUnLockedCountB <= #10 16'h0000;
                                   nextLockedCountB <= #10 16'h0000;
                                   nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                              end
                    end
               lfConfirmLockState : 
                    begin
                         if (lockedCountVotedB==lfLockThrCounterRegVotedB)
                              begin
                                   nextStateB <= #10 lfLockedState;
                                   nextLockedB <= #10 1'b1;
                                   nextUnLockedCountB <= #10 16'h0000;
                                   nextLockedCountB <= #10 16'h0000;
                                   nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                              end
                         else
                              begin
                                   if (instantLockVotedB)
                                        begin
                                             nextStateB <= #10 lfConfirmLockState;
                                             nextLockedB <= #10 1'b0;
                                             nextUnLockedCountB <= #10 16'h0000;
                                             nextLockedCountB <= #10 lockedCountVotedB+16'h0001;
                                             nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                                        end
                                   else
                                        begin
                                             nextStateB <= #10 lfUnlfLockedState;
                                             nextLockedB <= #10 1'b0;
                                             nextUnLockedCountB <= #10 16'h0000;
                                             nextLockedCountB <= #10 16'h0000;
                                             nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                                        end
                              end
                    end
               lfLockedState : 
                    begin
                         if (instantLockVotedB==1'b1)
                              begin
                                   nextStateB <= #10 lfLockedState;
                                   nextLockedB <= #10 1'b1;
                                   nextUnLockedCountB <= #10 16'h0000;
                                   nextLockedCountB <= #10 16'h0000;
                                   nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                              end
                         else
                              begin
                                   nextStateB <= #10 lfConfirmUnlockState;
                                   nextLockedB <= #10 1'b1;
                                   nextUnLockedCountB <= #10 16'h0001;
                                   nextLockedCountB <= #10 16'h0000;
                                   nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                              end
                    end
               lfConfirmUnlockState : 
                    begin
                         if (lockedCountVotedB==lfReLockThrCounterRegVotedB)
                              begin
                                   nextStateB <= #10 lfLockedState;
                                   nextLockedB <= #10 1'b1;
                                   nextUnLockedCountB <= #10 16'h0000;
                                   nextLockedCountB <= #10 16'h0000;
                                   nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                              end
                         else
                              begin
                                   if (unLockedCountVotedB==lfUnLockThrCounterRegVotedB)
                                        begin
                                             nextStateB <= #10 lfUnlfLockedState;
                                             nextLockedB <= #10 1'b0;
                                             nextUnLockedCountB <= #10 16'h0000;
                                             nextLockedCountB <= #10 16'h0000;
                                             nextLossOfLockCountB <= #10 lossOfLockCountVotedB+8'h01;
                                        end
                                   else
                                        begin
                                             if (instantLockVotedB==1'b1)
                                                  begin
                                                       nextStateB <= #10 lfConfirmUnlockState;
                                                       nextLockedB <= #10 1'b1;
                                                       nextUnLockedCountB <= #10 unLockedCountVotedB;
                                                       nextLockedCountB <= #10 lockedCountVotedB+16'h0001;
                                                       nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                                                  end
                                             else
                                                  begin
                                                       nextStateB <= #10 lfConfirmUnlockState;
                                                       nextLockedB <= #10 1'b1;
                                                       nextUnLockedCountB <= #10 unLockedCountVotedB+16'h0001;
                                                       nextLockedCountB <= #10 16'h0000;
                                                       nextLossOfLockCountB <= #10 lossOfLockCountVotedB;
                                                  end
                                        end
                              end
                    end
          endcase
     end

always @*
     begin
          case (stateVotedC)
               lfUnlfLockedState : 
                    begin
                         if (instantLockVotedC)
                              begin
                                   nextStateC <= #10 lfConfirmLockState;
                                   nextLockedC <= #10 1'b0;
                                   nextUnLockedCountC <= #10 16'h0000;
                                   nextLockedCountC <= #10 lockedCountVotedC+16'h0001;
                                   nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                              end
                         else
                              begin
                                   nextStateC <= #10 lfUnlfLockedState;
                                   nextLockedC <= #10 1'b0;
                                   nextUnLockedCountC <= #10 16'h0000;
                                   nextLockedCountC <= #10 16'h0000;
                                   nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                              end
                    end
               lfConfirmLockState : 
                    begin
                         if (lockedCountVotedC==lfLockThrCounterRegVotedC)
                              begin
                                   nextStateC <= #10 lfLockedState;
                                   nextLockedC <= #10 1'b1;
                                   nextUnLockedCountC <= #10 16'h0000;
                                   nextLockedCountC <= #10 16'h0000;
                                   nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                              end
                         else
                              begin
                                   if (instantLockVotedC)
                                        begin
                                             nextStateC <= #10 lfConfirmLockState;
                                             nextLockedC <= #10 1'b0;
                                             nextUnLockedCountC <= #10 16'h0000;
                                             nextLockedCountC <= #10 lockedCountVotedC+16'h0001;
                                             nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                                        end
                                   else
                                        begin
                                             nextStateC <= #10 lfUnlfLockedState;
                                             nextLockedC <= #10 1'b0;
                                             nextUnLockedCountC <= #10 16'h0000;
                                             nextLockedCountC <= #10 16'h0000;
                                             nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                                        end
                              end
                    end
               lfLockedState : 
                    begin
                         if (instantLockVotedC==1'b1)
                              begin
                                   nextStateC <= #10 lfLockedState;
                                   nextLockedC <= #10 1'b1;
                                   nextUnLockedCountC <= #10 16'h0000;
                                   nextLockedCountC <= #10 16'h0000;
                                   nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                              end
                         else
                              begin
                                   nextStateC <= #10 lfConfirmUnlockState;
                                   nextLockedC <= #10 1'b1;
                                   nextUnLockedCountC <= #10 16'h0001;
                                   nextLockedCountC <= #10 16'h0000;
                                   nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                              end
                    end
               lfConfirmUnlockState : 
                    begin
                         if (lockedCountVotedC==lfReLockThrCounterRegVotedC)
                              begin
                                   nextStateC <= #10 lfLockedState;
                                   nextLockedC <= #10 1'b1;
                                   nextUnLockedCountC <= #10 16'h0000;
                                   nextLockedCountC <= #10 16'h0000;
                                   nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                              end
                         else
                              begin
                                   if (unLockedCountVotedC==lfUnLockThrCounterRegVotedC)
                                        begin
                                             nextStateC <= #10 lfUnlfLockedState;
                                             nextLockedC <= #10 1'b0;
                                             nextUnLockedCountC <= #10 16'h0000;
                                             nextLockedCountC <= #10 16'h0000;
                                             nextLossOfLockCountC <= #10 lossOfLockCountVotedC+8'h01;
                                        end
                                   else
                                        begin
                                             if (instantLockVotedC==1'b1)
                                                  begin
                                                       nextStateC <= #10 lfConfirmUnlockState;
                                                       nextLockedC <= #10 1'b1;
                                                       nextUnLockedCountC <= #10 unLockedCountVotedC;
                                                       nextLockedCountC <= #10 lockedCountVotedC+16'h0001;
                                                       nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                                                  end
                                             else
                                                  begin
                                                       nextStateC <= #10 lfConfirmUnlockState;
                                                       nextLockedC <= #10 1'b1;
                                                       nextUnLockedCountC <= #10 unLockedCountVotedC+16'h0001;
                                                       nextLockedCountC <= #10 16'h0000;
                                                       nextLossOfLockCountC <= #10 lossOfLockCountVotedC;
                                                  end
                                        end
                              end
                    end
          endcase
     end

always @( posedge clockA or posedge resetVotedA )
     begin
          if (resetVotedA==1'b1)
               begin
                    lockedA <= #10 1'b0;
                    stateA <= #10 lfUnlfLockedState;
                    unLockedCountA <= #10 16'h0000;
                    lockedCountA <= #10 16'h0000;
                    lossOfLockCountA <= #10 nextLossOfLockCountVotedA;
               end
          else
               begin
                    lockedA <= #10 nextLockedVotedA;
                    stateA <= #10 nextStateVotedA;
                    unLockedCountA <= #10 nextUnLockedCountVotedA;
                    lockedCountA <= #10 nextLockedCountVotedA;
                    lossOfLockCountA <= #10 nextLossOfLockCountVotedA;
               end
     end

always @( posedge clockB or posedge resetVotedB )
     begin
          if (resetVotedB==1'b1)
               begin
                    lockedB <= #10 1'b0;
                    stateB <= #10 lfUnlfLockedState;
                    unLockedCountB <= #10 16'h0000;
                    lockedCountB <= #10 16'h0000;
                    lossOfLockCountB <= #10 nextLossOfLockCountVotedB;
               end
          else
               begin
                    lockedB <= #10 nextLockedVotedB;
                    stateB <= #10 nextStateVotedB;
                    unLockedCountB <= #10 nextUnLockedCountVotedB;
                    lockedCountB <= #10 nextLockedCountVotedB;
                    lossOfLockCountB <= #10 nextLossOfLockCountVotedB;
               end
     end

always @( posedge clockC or posedge resetVotedC )
     begin
          if (resetVotedC==1'b1)
               begin
                    lockedC <= #10 1'b0;
                    stateC <= #10 lfUnlfLockedState;
                    unLockedCountC <= #10 16'h0000;
                    lockedCountC <= #10 16'h0000;
                    lossOfLockCountC <= #10 nextLossOfLockCountVotedC;
               end
          else
               begin
                    lockedC <= #10 nextLockedVotedC;
                    stateC <= #10 nextStateVotedC;
                    unLockedCountC <= #10 nextUnLockedCountVotedC;
                    lockedCountC <= #10 nextLockedCountVotedC;
                    lossOfLockCountC <= #10 nextLossOfLockCountVotedC;
               end
     end
// synopsys translate_off
initial
     begin
          nextLossOfLockCountA =  $random;
     end
initial
     begin
          nextLossOfLockCountB =  $random;
     end
initial
     begin
          nextLossOfLockCountC =  $random;
     end
// synopsys translate_on

majorityVoter #(.WIDTH(8)) lossOfLockCountVoterA (
          .inA(lossOfLockCountA),
          .inB(lossOfLockCountB),
          .inC(lossOfLockCountC),
          .out(lossOfLockCountVotedA),
          .tmrErr(lossOfLockCountTmrErrorA)
          );

majorityVoter #(.WIDTH(16)) lfUnLockThrCounterRegVoterA (
          .inA(lfUnLockThrCounterRegA),
          .inB(lfUnLockThrCounterRegB),
          .inC(lfUnLockThrCounterRegC),
          .out(lfUnLockThrCounterRegVotedA),
          .tmrErr(lfUnLockThrCounterRegTmrErrorA)
          );

majorityVoter #(.WIDTH(16)) lfLockThrCounterRegVoterA (
          .inA(lfLockThrCounterRegA),
          .inB(lfLockThrCounterRegB),
          .inC(lfLockThrCounterRegC),
          .out(lfLockThrCounterRegVotedA),
          .tmrErr(lfLockThrCounterRegTmrErrorA)
          );

majorityVoter instantLockVoterA (
          .inA(instantLockA),
          .inB(instantLockB),
          .inC(instantLockC),
          .out(instantLockVotedA),
          .tmrErr(instantLockTmrErrorA)
          );

majorityVoter #(.WIDTH(16)) nextLockedCountVoterA (
          .inA(nextLockedCountA),
          .inB(nextLockedCountB),
          .inC(nextLockedCountC),
          .out(nextLockedCountVotedA),
          .tmrErr(nextLockedCountTmrErrorA)
          );

majorityVoter #(.WIDTH(16)) lfReLockThrCounterRegVoterA (
          .inA(lfReLockThrCounterRegA),
          .inB(lfReLockThrCounterRegB),
          .inC(lfReLockThrCounterRegC),
          .out(lfReLockThrCounterRegVotedA),
          .tmrErr(lfReLockThrCounterRegTmrErrorA)
          );

majorityVoter #(.WIDTH(2)) nextStateVoterA (
          .inA(nextStateA),
          .inB(nextStateB),
          .inC(nextStateC),
          .out(nextStateVotedA),
          .tmrErr(nextStateTmrErrorA)
          );

majorityVoter nextLockedVoterA (
          .inA(nextLockedA),
          .inB(nextLockedB),
          .inC(nextLockedC),
          .out(nextLockedVotedA),
          .tmrErr(nextLockedTmrErrorA)
          );

majorityVoter #(.WIDTH(16)) nextUnLockedCountVoterA (
          .inA(nextUnLockedCountA),
          .inB(nextUnLockedCountB),
          .inC(nextUnLockedCountC),
          .out(nextUnLockedCountVotedA),
          .tmrErr(nextUnLockedCountTmrErrorA)
          );

majorityVoter #(.WIDTH(16)) unLockedCountVoterA (
          .inA(unLockedCountA),
          .inB(unLockedCountB),
          .inC(unLockedCountC),
          .out(unLockedCountVotedA),
          .tmrErr(unLockedCountTmrErrorA)
          );

majorityVoter resetVoterA (
          .inA(resetA),
          .inB(resetB),
          .inC(resetC),
          .out(resetVotedA),
          .tmrErr(resetTmrErrorA)
          );

majorityVoter #(.WIDTH(8)) nextLossOfLockCountVoterA (
          .inA(nextLossOfLockCountA),
          .inB(nextLossOfLockCountB),
          .inC(nextLossOfLockCountC),
          .out(nextLossOfLockCountVotedA),
          .tmrErr(nextLossOfLockCountTmrErrorA)
          );

majorityVoter #(.WIDTH(2)) stateVoterA (
          .inA(stateA),
          .inB(stateB),
          .inC(stateC),
          .out(stateVotedA),
          .tmrErr(stateTmrErrorA)
          );

majorityVoter #(.WIDTH(16)) lockedCountVoterA (
          .inA(lockedCountA),
          .inB(lockedCountB),
          .inC(lockedCountC),
          .out(lockedCountVotedA),
          .tmrErr(lockedCountTmrErrorA)
          );

majorityVoter #(.WIDTH(8)) lossOfLockCountVoterB (
          .inA(lossOfLockCountA),
          .inB(lossOfLockCountB),
          .inC(lossOfLockCountC),
          .out(lossOfLockCountVotedB),
          .tmrErr(lossOfLockCountTmrErrorB)
          );

majorityVoter #(.WIDTH(16)) lfLockThrCounterRegVoterB (
          .inA(lfLockThrCounterRegA),
          .inB(lfLockThrCounterRegB),
          .inC(lfLockThrCounterRegC),
          .out(lfLockThrCounterRegVotedB),
          .tmrErr(lfLockThrCounterRegTmrErrorB)
          );

majorityVoter #(.WIDTH(16)) lockedCountVoterB (
          .inA(lockedCountA),
          .inB(lockedCountB),
          .inC(lockedCountC),
          .out(lockedCountVotedB),
          .tmrErr(lockedCountTmrErrorB)
          );

majorityVoter #(.WIDTH(2)) nextStateVoterB (
          .inA(nextStateA),
          .inB(nextStateB),
          .inC(nextStateC),
          .out(nextStateVotedB),
          .tmrErr(nextStateTmrErrorB)
          );

majorityVoter instantLockVoterB (
          .inA(instantLockA),
          .inB(instantLockB),
          .inC(instantLockC),
          .out(instantLockVotedB),
          .tmrErr(instantLockTmrErrorB)
          );

majorityVoter nextLockedVoterB (
          .inA(nextLockedA),
          .inB(nextLockedB),
          .inC(nextLockedC),
          .out(nextLockedVotedB),
          .tmrErr(nextLockedTmrErrorB)
          );

majorityVoter #(.WIDTH(16)) lfReLockThrCounterRegVoterB (
          .inA(lfReLockThrCounterRegA),
          .inB(lfReLockThrCounterRegB),
          .inC(lfReLockThrCounterRegC),
          .out(lfReLockThrCounterRegVotedB),
          .tmrErr(lfReLockThrCounterRegTmrErrorB)
          );

majorityVoter #(.WIDTH(16)) nextUnLockedCountVoterB (
          .inA(nextUnLockedCountA),
          .inB(nextUnLockedCountB),
          .inC(nextUnLockedCountC),
          .out(nextUnLockedCountVotedB),
          .tmrErr(nextUnLockedCountTmrErrorB)
          );

majorityVoter #(.WIDTH(8)) nextLossOfLockCountVoterB (
          .inA(nextLossOfLockCountA),
          .inB(nextLossOfLockCountB),
          .inC(nextLossOfLockCountC),
          .out(nextLossOfLockCountVotedB),
          .tmrErr(nextLossOfLockCountTmrErrorB)
          );

majorityVoter resetVoterB (
          .inA(resetA),
          .inB(resetB),
          .inC(resetC),
          .out(resetVotedB),
          .tmrErr(resetTmrErrorB)
          );

majorityVoter #(.WIDTH(16)) unLockedCountVoterB (
          .inA(unLockedCountA),
          .inB(unLockedCountB),
          .inC(unLockedCountC),
          .out(unLockedCountVotedB),
          .tmrErr(unLockedCountTmrErrorB)
          );

majorityVoter #(.WIDTH(16)) nextLockedCountVoterB (
          .inA(nextLockedCountA),
          .inB(nextLockedCountB),
          .inC(nextLockedCountC),
          .out(nextLockedCountVotedB),
          .tmrErr(nextLockedCountTmrErrorB)
          );

majorityVoter #(.WIDTH(2)) stateVoterB (
          .inA(stateA),
          .inB(stateB),
          .inC(stateC),
          .out(stateVotedB),
          .tmrErr(stateTmrErrorB)
          );

majorityVoter #(.WIDTH(16)) lfUnLockThrCounterRegVoterB (
          .inA(lfUnLockThrCounterRegA),
          .inB(lfUnLockThrCounterRegB),
          .inC(lfUnLockThrCounterRegC),
          .out(lfUnLockThrCounterRegVotedB),
          .tmrErr(lfUnLockThrCounterRegTmrErrorB)
          );

majorityVoter #(.WIDTH(8)) lossOfLockCountVoterC (
          .inA(lossOfLockCountA),
          .inB(lossOfLockCountB),
          .inC(lossOfLockCountC),
          .out(lossOfLockCountVotedC),
          .tmrErr(lossOfLockCountTmrErrorC)
          );

majorityVoter #(.WIDTH(2)) nextStateVoterC (
          .inA(nextStateA),
          .inB(nextStateB),
          .inC(nextStateC),
          .out(nextStateVotedC),
          .tmrErr(nextStateTmrErrorC)
          );

majorityVoter #(.WIDTH(16)) lfUnLockThrCounterRegVoterC (
          .inA(lfUnLockThrCounterRegA),
          .inB(lfUnLockThrCounterRegB),
          .inC(lfUnLockThrCounterRegC),
          .out(lfUnLockThrCounterRegVotedC),
          .tmrErr(lfUnLockThrCounterRegTmrErrorC)
          );

majorityVoter #(.WIDTH(16)) lfLockThrCounterRegVoterC (
          .inA(lfLockThrCounterRegA),
          .inB(lfLockThrCounterRegB),
          .inC(lfLockThrCounterRegC),
          .out(lfLockThrCounterRegVotedC),
          .tmrErr(lfLockThrCounterRegTmrErrorC)
          );

majorityVoter instantLockVoterC (
          .inA(instantLockA),
          .inB(instantLockB),
          .inC(instantLockC),
          .out(instantLockVotedC),
          .tmrErr(instantLockTmrErrorC)
          );

majorityVoter #(.WIDTH(16)) lockedCountVoterC (
          .inA(lockedCountA),
          .inB(lockedCountB),
          .inC(lockedCountC),
          .out(lockedCountVotedC),
          .tmrErr(lockedCountTmrErrorC)
          );

majorityVoter nextLockedVoterC (
          .inA(nextLockedA),
          .inB(nextLockedB),
          .inC(nextLockedC),
          .out(nextLockedVotedC),
          .tmrErr(nextLockedTmrErrorC)
          );

majorityVoter #(.WIDTH(16)) lfReLockThrCounterRegVoterC (
          .inA(lfReLockThrCounterRegA),
          .inB(lfReLockThrCounterRegB),
          .inC(lfReLockThrCounterRegC),
          .out(lfReLockThrCounterRegVotedC),
          .tmrErr(lfReLockThrCounterRegTmrErrorC)
          );

majorityVoter #(.WIDTH(16)) nextUnLockedCountVoterC (
          .inA(nextUnLockedCountA),
          .inB(nextUnLockedCountB),
          .inC(nextUnLockedCountC),
          .out(nextUnLockedCountVotedC),
          .tmrErr(nextUnLockedCountTmrErrorC)
          );

majorityVoter #(.WIDTH(16)) nextLockedCountVoterC (
          .inA(nextLockedCountA),
          .inB(nextLockedCountB),
          .inC(nextLockedCountC),
          .out(nextLockedCountVotedC),
          .tmrErr(nextLockedCountTmrErrorC)
          );

majorityVoter #(.WIDTH(16)) unLockedCountVoterC (
          .inA(unLockedCountA),
          .inB(unLockedCountB),
          .inC(unLockedCountC),
          .out(unLockedCountVotedC),
          .tmrErr(unLockedCountTmrErrorC)
          );

majorityVoter resetVoterC (
          .inA(resetA),
          .inB(resetB),
          .inC(resetC),
          .out(resetVotedC),
          .tmrErr(resetTmrErrorC)
          );

majorityVoter #(.WIDTH(2)) stateVoterC (
          .inA(stateA),
          .inB(stateB),
          .inC(stateC),
          .out(stateVotedC),
          .tmrErr(stateTmrErrorC)
          );

majorityVoter #(.WIDTH(8)) nextLossOfLockCountVoterC (
          .inA(nextLossOfLockCountA),
          .inB(nextLossOfLockCountB),
          .inC(nextLossOfLockCountC),
          .out(nextLossOfLockCountVotedC),
          .tmrErr(nextLossOfLockCountTmrErrorC)
          );
endmodule

