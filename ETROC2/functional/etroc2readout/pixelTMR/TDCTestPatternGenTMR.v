/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./pixelTMR/TDCTestPatternGenTMR.v                                                      *
 *                                                                                                  *
 * user    : dataogong                                                                              *
 * host    : 16-11005.local                                                                         *
 * date    : 13/04/2021 11:53:04                                                                    *
 *                                                                                                  *
 * workdir : /Users/dataogong/Documents/Gitlab/ETROCI2C/etroc2_swreadout/rtl/ETROC2Readout          *
 * cmd     : /Users/dataogong/Documents/ActiveDocument/Gitlab/tmrg/bin/tmrg -c tmrgPixel.cnf        *
 * tmrg rev: e2867c77ccb74667bff8dd6a91891cdefaaa0580                                               *
 *                                                                                                  *
 * src file: TDCTestPatternGen.v                                                                    *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2021-04-13 11:38:22.142622                                         *
 *           File Size         : 2880                                                               *
 *           MD5 hash          : 3b7ae09032746b3f7599982b66584138                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale  1ns / 100ps

`include  "commonDefinition.v"

module TDCTestPatternGenTMR(
     input  clk,
     input  reset,
     input  dis,
     input  mode,
     input [7:0] pixelID,
     input [8:0] latencyL1A,
     input [6:0] occupancy,
     output wire [29:0] dout
);
wire [7:0] pixelIDC;
wire [7:0] pixelIDB;
wire [7:0] pixelIDA;
wire [6:0] occupancyC;
wire [6:0] occupancyB;
wire [6:0] occupancyA;
wire modeC;
wire modeB;
wire modeA;
wire clkC;
wire clkB;
wire clkA;
wire resetC;
wire resetB;
wire resetA;
wire [8:0] latencyL1AC;
wire [8:0] latencyL1AB;
wire [8:0] latencyL1AA;
wire disC;
wire disB;
wire disA;
wor nextCounterL1ATmrErrorC;
wire [8:0] nextCounterL1AVotedC;
wor nextCounterL1ATmrErrorB;
wire [8:0] nextCounterL1AVotedB;
wor nextCounterL1ATmrErrorA;
wire [8:0] nextCounterL1AVotedA;
wor hitTmrError;
wire hit;
wor genBCIDTmrError;
wire [11:0] genBCID;
wor usedCounterTmrError;
wire [8:0] usedCounter;
wire [14:0] prbsA;
wire [14:0] prbsB;
wire [14:0] prbsC;
wire [30:0] seedA;
wire [30:0] seedB;
wire [30:0] seedC;
assign seedA =  {23'h2AAAAA,8'haa^pixelIDA};
assign seedB =  {23'h2AAAAA,8'haa^pixelIDB};
assign seedC =  {23'h2AAAAA,8'haa^pixelIDC};

PRBS31TMR #(.WORDWIDTH(15), .FORWARDSTEPS(0)) prbs_inst (
          .clkA(clkA),
          .clkB(clkB),
          .clkC(clkC),
          .resetA(resetA),
          .resetB(resetB),
          .resetC(resetC),
          .disA(disA),
          .disB(disB),
          .disC(disC),
          .seedA(seedA),
          .seedB(seedB),
          .seedC(seedC),
          .prbsA(prbsA),
          .prbsB(prbsB),
          .prbsC(prbsC)
          );
wire predictL1AA;
wire predictL1AB;
wire predictL1AC;

TestL1GeneratorTMR #(.WORDWIDTH(15), .FORWARDSTEPS(`DEFAULT_L1A_LATENCY-1)) predict_trigger (
          .clkA(clkA),
          .clkB(clkB),
          .clkC(clkC),
          .resetA(resetA),
          .resetB(resetB),
          .resetC(resetC),
          .disA(disA),
          .disB(disB),
          .disC(disC),
          .modeA(modeA),
          .modeB(modeB),
          .modeC(modeC),
          .L1AA(predictL1AA),
          .L1AB(predictL1AB),
          .L1AC(predictL1AC)
          );
wire hitA;
wire hitB;
wire hitC;
wire [15:0] thresholdA;
wire [15:0] thresholdB;
wire [15:0] thresholdC;
assign thresholdA =  ({1'b0,occupancyA}<<8);
assign thresholdB =  ({1'b0,occupancyB}<<8);
assign thresholdC =  ({1'b0,occupancyC}<<8);
assign hitA =  ({1'b0,prbsA}<thresholdA);
assign hitB =  ({1'b0,prbsB}<thresholdB);
assign hitC =  ({1'b0,prbsC}<thresholdC);
reg  [8:0] counterL1AA;
reg  [8:0] counterL1AB;
reg  [8:0] counterL1AC;
wire [8:0] nextCounterL1AA =  counterL1AA+1;
wire [8:0] nextCounterL1AB =  counterL1AB+1;
wire [8:0] nextCounterL1AC =  counterL1AC+1;

always @( posedge clkA )
     begin
          if (!disA)
               begin
                    if (!resetA)
                         begin
                              counterL1AA <= 9'h000;
                         end
                    else
                         begin
                              if (predictL1AA==1'b1&&hitA==1'b1)
                                   begin
                                        counterL1AA <= nextCounterL1AVotedA;
                                   end
                         end
               end
     end

always @( posedge clkB )
     begin
          if (!disB)
               begin
                    if (!resetB)
                         begin
                              counterL1AB <= 9'h000;
                         end
                    else
                         begin
                              if (predictL1AB==1'b1&&hitB==1'b1)
                                   begin
                                        counterL1AB <= nextCounterL1AVotedB;
                                   end
                         end
               end
     end

always @( posedge clkC )
     begin
          if (!disC)
               begin
                    if (!resetC)
                         begin
                              counterL1AC <= 9'h000;
                         end
                    else
                         begin
                              if (predictL1AC==1'b1&&hitC==1'b1)
                                   begin
                                        counterL1AC <= nextCounterL1AVotedC;
                                   end
                         end
               end
     end
wire [11:0] genBCIDA;
wire [11:0] genBCIDB;
wire [11:0] genBCIDC;
wire [11:0] offsetA =  latencyL1AA+2;
wire [11:0] offsetB =  latencyL1AB+2;
wire [11:0] offsetC =  latencyL1AC+2;

BCIDCounterTMR BC (
          .clkA(clkA),
          .clkB(clkB),
          .clkC(clkC),
          .resetA(resetA),
          .resetB(resetB),
          .resetC(resetC),
          .disA(disA),
          .disB(disB),
          .disC(disC),
          .rstBCIDA(1'b1),
          .rstBCIDB(1'b1),
          .rstBCIDC(1'b1),
          .offsetA(offsetA),
          .offsetB(offsetB),
          .offsetC(offsetC),
          .BCIDA(genBCIDA),
          .BCIDB(genBCIDB),
          .BCIDC(genBCIDC)
          );
wire [8:0] usedCounterA;
wire [8:0] usedCounterB;
wire [8:0] usedCounterC;
assign usedCounterA =  (modeA==1'b1)&&(predictL1AA==1'b1&&hitA==1'b1) ? counterL1AA : 9'h1aa;
assign usedCounterB =  (modeB==1'b1)&&(predictL1AB==1'b1&&hitB==1'b1) ? counterL1AB : 9'h1aa;
assign usedCounterC =  (modeC==1'b1)&&(predictL1AC==1'b1&&hitC==1'b1) ? counterL1AC : 9'h1aa;
assign dout =  dis ? { 30 {1'b0} }  : {pixelID,genBCID,usedCounter,hit};

majorityVoter #(.WIDTH(9)) usedCounterVoter (
          .inA(usedCounterA),
          .inB(usedCounterB),
          .inC(usedCounterC),
          .out(usedCounter),
          .tmrErr(usedCounterTmrError)
          );

majorityVoter #(.WIDTH(12)) genBCIDVoter (
          .inA(genBCIDA),
          .inB(genBCIDB),
          .inC(genBCIDC),
          .out(genBCID),
          .tmrErr(genBCIDTmrError)
          );

majorityVoter hitVoter (
          .inA(hitA),
          .inB(hitB),
          .inC(hitC),
          .out(hit),
          .tmrErr(hitTmrError)
          );

majorityVoter #(.WIDTH(9)) nextCounterL1AVoterA (
          .inA(nextCounterL1AA),
          .inB(nextCounterL1AB),
          .inC(nextCounterL1AC),
          .out(nextCounterL1AVotedA),
          .tmrErr(nextCounterL1ATmrErrorA)
          );

majorityVoter #(.WIDTH(9)) nextCounterL1AVoterB (
          .inA(nextCounterL1AA),
          .inB(nextCounterL1AB),
          .inC(nextCounterL1AC),
          .out(nextCounterL1AVotedB),
          .tmrErr(nextCounterL1ATmrErrorB)
          );

majorityVoter #(.WIDTH(9)) nextCounterL1AVoterC (
          .inA(nextCounterL1AA),
          .inB(nextCounterL1AB),
          .inC(nextCounterL1AC),
          .out(nextCounterL1AVotedC),
          .tmrErr(nextCounterL1ATmrErrorC)
          );

fanout disFanout (
          .in(dis),
          .outA(disA),
          .outB(disB),
          .outC(disC)
          );

fanout #(.WIDTH(9)) latencyL1AFanout (
          .in(latencyL1A),
          .outA(latencyL1AA),
          .outB(latencyL1AB),
          .outC(latencyL1AC)
          );

fanout resetFanout (
          .in(reset),
          .outA(resetA),
          .outB(resetB),
          .outC(resetC)
          );

fanout clkFanout (
          .in(clk),
          .outA(clkA),
          .outB(clkB),
          .outC(clkC)
          );

fanout modeFanout (
          .in(mode),
          .outA(modeA),
          .outB(modeB),
          .outC(modeC)
          );

fanout #(.WIDTH(7)) occupancyFanout (
          .in(occupancy),
          .outA(occupancyA),
          .outB(occupancyB),
          .outC(occupancyC)
          );

fanout #(.WIDTH(8)) pixelIDFanout (
          .in(pixelID),
          .outA(pixelIDA),
          .outB(pixelIDB),
          .outC(pixelIDC)
          );
endmodule



// /Users/dataogong/Documents/ActiveDocument/Gitlab/tmrg/tmrg/../common/voter.v
module majorityVoter (inA, inB, inC, out, tmrErr);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   inA, inB, inC;
  output  [(WIDTH-1):0]   out;
  output                  tmrErr;
  reg                     tmrErr;
  assign out = (inA&inB) | (inA&inC) | (inB&inC);
  always @(inA or inB or inC)
  begin
    if (inA!=inB || inA!=inC || inB!=inC)
      tmrErr = 1;
    else
      tmrErr = 0;
  end
endmodule


// /Users/dataogong/Documents/ActiveDocument/Gitlab/tmrg/tmrg/../common/fanout.v
module fanout (in, outA, outB, outC);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   in;
  output  [(WIDTH-1):0]   outA,outB,outC;
  assign outA=in;
  assign outB=in;
  assign outC=in;
endmodule
